<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OpenDemocracy — Peer-to-Peer</title>
<style>
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface2: #242836;
    --border: #2e3345;
    --text: #e4e6f0;
    --text2: #9196ab;
    --accent: #6c8cff;
    --accent2: #4a6adf;
    --green: #4caf87;
    --green2: #3a9070;
    --red: #e05555;
    --orange: #e0993a;
    --radius: 12px;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.6;
    min-height: 100vh;
  }

  /* ---- Header ---- */
  header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 0.8rem 2rem;
    display: flex; align-items: center; justify-content: space-between;
    position: sticky; top: 0; z-index: 100;
    flex-wrap: wrap; gap: 0.5rem;
  }
  .logo { font-size: 1.2rem; font-weight: 700; letter-spacing: -0.02em; }
  .logo span { color: var(--accent); }
  .logo small { font-size: 0.7rem; font-weight: 400; color: var(--green); margin-left: 0.5rem; letter-spacing: 0.02em; }
  .header-stats { display: flex; gap: 1.5rem; font-size: 0.8rem; color: var(--text2); }
  .header-stats strong { color: var(--accent); font-weight: 600; }

  /* ---- Layout ---- */
  .container { max-width: 880px; margin: 0 auto; padding: 0 1.5rem; }
  section { margin-bottom: 2.5rem; }

  /* ---- Hero ---- */
  .hero { text-align: center; padding: 3rem 1rem 2rem; }
  .hero h2 {
    font-size: 2rem; font-weight: 700; letter-spacing: -0.03em;
    margin-bottom: 0.75rem; line-height: 1.2;
  }
  .hero h2 em { font-style: normal; color: var(--accent); }
  .hero p { color: var(--text2); font-size: 1.05rem; max-width: 560px; margin: 0 auto 1.5rem; }

  /* ---- Steps ---- */
  .steps {
    display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1rem; margin-bottom: 0.5rem;
  }
  .step {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 1.25rem; text-align: center;
  }
  .step .num {
    display: inline-block; width: 2rem; height: 2rem; line-height: 2rem;
    background: var(--accent); color: #fff; border-radius: 50%;
    font-size: 0.85rem; font-weight: 700; margin-bottom: 0.6rem;
  }
  .step h3 { font-size: 0.95rem; margin-bottom: 0.3rem; }
  .step p { font-size: 0.8rem; color: var(--text2); margin: 0; }

  /* ---- Cards ---- */
  .card {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 1.5rem; margin-bottom: 1rem;
  }
  .card h2 { font-size: 1.1rem; margin-bottom: 0.4rem; }
  .card p.desc { color: var(--text2); font-size: 0.9rem; margin-bottom: 1rem; }

  /* ---- Buttons ---- */
  button {
    background: var(--accent); color: #fff; border: none;
    border-radius: 8px; padding: 0.6rem 1.4rem;
    font-size: 0.9rem; font-weight: 500; cursor: pointer;
    transition: background 0.15s;
  }
  button:hover { background: var(--accent2); }
  button:disabled { opacity: 0.35; cursor: not-allowed; }
  button.green { background: var(--green); }
  button.green:hover { background: var(--green2); }
  button.secondary {
    background: var(--surface2); border: 1px solid var(--border); color: var(--text);
  }
  button.secondary:hover { background: var(--border); }
  button.full { width: 100%; }
  button.small { padding: 0.35rem 0.8rem; font-size: 0.8rem; }

  /* ---- Room banner ---- */
  .room-banner {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 1.25rem 1.5rem;
    margin-bottom: 1.5rem;
  }
  .room-banner .room-id {
    font-family: monospace; font-size: 1.1rem; font-weight: 700;
    color: var(--accent); letter-spacing: 0.03em;
  }
  .room-banner .room-meta { font-size: 0.82rem; color: var(--text2); margin-top: 0.3rem; }
  .room-actions { display: flex; gap: 0.5rem; margin-top: 0.75rem; flex-wrap: wrap; }

  /* ---- Peer indicator ---- */
  .peer-dot {
    display: inline-block; width: 8px; height: 8px; border-radius: 50%;
    background: var(--green); margin-right: 4px; vertical-align: middle;
  }
  .peer-dot.off { background: var(--red); }

  /* ---- Identity banner ---- */
  .id-banner {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 1.25rem 1.5rem;
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 1.5rem; gap: 1rem; flex-wrap: wrap;
  }
  .id-banner .meta { font-size: 0.85rem; color: var(--text2); }
  .id-banner .status { font-weight: 600; font-size: 0.95rem; }
  .enrolled { color: var(--green); }
  .not-enrolled { color: var(--orange); }

  /* ---- Biometric factors ---- */
  .factors {
    display: grid; grid-template-columns: repeat(4, 1fr);
    gap: 0.75rem; margin-bottom: 1.25rem;
  }
  @media (max-width: 500px) { .factors { grid-template-columns: repeat(2, 1fr); } }
  .factor {
    background: var(--surface2); border: 2px solid var(--border);
    border-radius: 10px; padding: 1rem 0.5rem;
    text-align: center; cursor: pointer; transition: all 0.15s; user-select: none;
  }
  .factor:hover { border-color: var(--accent); color: var(--text); }
  .factor.on {
    border-color: var(--green); background: rgba(76, 175, 135, 0.08); color: var(--text);
  }
  .factor .ic { font-size: 2rem; margin-bottom: 0.2rem; }
  .factor .nm { font-size: 0.8rem; font-weight: 500; color: var(--text2); }
  .factor.on .nm { color: var(--green); }
  .factor .check { display: none; font-size: 0.7rem; color: var(--green); }
  .factor.on .check { display: block; }

  /* ---- Progress bar ---- */
  .prog { height: 4px; background: var(--border); border-radius: 2px; margin-bottom: 1rem; overflow: hidden; }
  .prog .bar { height: 100%; background: var(--green); border-radius: 2px; transition: width 0.4s ease; }

  /* ---- Forms ---- */
  textarea, select, input[type="text"] {
    width: 100%; background: var(--surface2);
    border: 1px solid var(--border); border-radius: 8px;
    padding: 0.7rem 1rem; color: var(--text);
    font-size: 0.9rem; font-family: inherit; resize: vertical;
  }
  textarea:focus, select:focus, input:focus { outline: none; border-color: var(--accent); }
  label { display: block; font-size: 0.8rem; font-weight: 500; color: var(--text2); margin-bottom: 0.35rem; }
  .field { margin-bottom: 1rem; }

  /* ---- Tabs ---- */
  .tabs { display: flex; gap: 0.5rem; margin-bottom: 1.25rem; }
  .tab {
    padding: 0.45rem 1rem; background: var(--surface2);
    border: 1px solid var(--border); border-radius: 8px;
    font-size: 0.8rem; cursor: pointer; color: var(--text2); transition: all 0.15s;
  }
  .tab:hover { color: var(--text); }
  .tab.on { background: var(--accent); border-color: var(--accent); color: #fff; }

  /* ---- Submissions ---- */
  .sub-item {
    background: var(--surface2); border-radius: 8px;
    padding: 0.7rem 1rem; margin-bottom: 0.5rem; font-size: 0.9rem;
  }
  .badge {
    display: inline-block; font-size: 0.7rem; font-weight: 600;
    padding: 0.12rem 0.45rem; border-radius: 4px; margin-right: 0.5rem;
    text-transform: uppercase; letter-spacing: 0.02em;
  }
  .badge-opinion { background: rgba(108,140,255,0.2); color: var(--accent); }
  .badge-idea { background: rgba(224,153,58,0.2); color: var(--orange); }
  .badge-vote { background: rgba(76,175,135,0.2); color: var(--green); }

  /* ---- Topic list ---- */
  .topic { cursor: pointer; transition: border-color 0.15s; }
  .topic:hover { border-color: var(--accent); }
  .topic.on { border-color: var(--accent); background: rgba(108,140,255,0.04); }
  .topic h3 { font-size: 1rem; margin-bottom: 0.25rem; }
  .topic p { margin: 0; }

  /* ---- Alert ---- */
  .alert { padding: 0.7rem 1rem; border-radius: 8px; font-size: 0.85rem; margin-bottom: 1rem; display: none; }
  .alert.ok { background: rgba(76,175,135,0.12); color: var(--green); display: block; }
  .alert.err { background: rgba(224,85,85,0.12); color: var(--red); display: block; }

  /* ---- Privacy ---- */
  .privacy {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 1.25rem 1.5rem;
    margin-bottom: 2rem; font-size: 0.85rem; color: var(--text2); line-height: 1.7;
  }
  .privacy strong { color: var(--text); }

  .hidden { display: none !important; }

  footer {
    text-align: center; padding: 2rem 1rem;
    color: var(--text2); font-size: 0.78rem;
    border-top: 1px solid var(--border);
  }
  footer a { color: var(--accent); text-decoration: none; }

  /* ---- Create topic form ---- */
  .create-topic-form { margin-top: 1rem; }
  .create-topic-form .field { margin-bottom: 0.75rem; }

  /* ---- Network log ---- */
  .net-log {
    font-family: monospace; font-size: 0.75rem; color: var(--text2);
    background: var(--surface2); border-radius: 8px;
    padding: 0.75rem 1rem; max-height: 120px; overflow-y: auto;
    margin-top: 0.75rem;
  }
  .net-log div { margin-bottom: 2px; }
  .net-log .ok { color: var(--green); }
  .net-log .warn { color: var(--orange); }
  .net-log .err { color: var(--red); }
</style>
</head>
<body>

<!-- ================================================================ -->
<!-- HEADER                                                           -->
<!-- ================================================================ -->
<header>
  <div class="logo"><span>Open</span>Democracy<small>P2P</small></div>
  <div class="header-stats">
    <span><span class="peer-dot" id="net-dot"></span> Peers: <strong id="st-peers">0</strong></span>
    <span>Verified: <strong id="st-enrolled">0</strong></span>
    <span>Submissions: <strong id="st-subs">0</strong></span>
    <span title="IndexedDB persistence" id="st-storage">Storage: <strong>--</strong></span>
  </div>
</header>

<div class="container">

  <!-- ============================================================== -->
  <!-- HERO                                                           -->
  <!-- ============================================================== -->
  <div class="hero">
    <h2>Your voice. <em>Verified.</em><br>No server needed.</h2>
    <p>Peer-to-peer democracy. Every browser is the server.
       Share a link, connect directly, vote — like BitTorrent for democracy.</p>
  </div>

  <!-- ============================================================== -->
  <!-- HOW IT WORKS                                                   -->
  <!-- ============================================================== -->
  <section>
    <div class="steps">
      <div class="step">
        <div class="num">1</div>
        <h3>Create or join a room</h3>
        <p>One person starts a room. Others join with the link.</p>
      </div>
      <div class="step">
        <div class="num">2</div>
        <h3>Verify your identity</h3>
        <p>Biometric scan on your device. Keys stay local.</p>
      </div>
      <div class="step">
        <div class="num">3</div>
        <h3>Participate</h3>
        <p>Submit opinions, ideas, or votes — replicated to all peers.</p>
      </div>
      <div class="step">
        <div class="num">4</div>
        <h3>Everyone verifies</h3>
        <p>Each browser checks every signature independently.</p>
      </div>
    </div>
  </section>

  <!-- alert -->
  <div class="alert" id="alert"></div>

  <!-- ============================================================== -->
  <!-- ROOM (create or join)                                          -->
  <!-- ============================================================== -->
  <section id="sec-room">
    <!-- Before joining/creating -->
    <div id="room-setup" class="card">
      <h2>Start or Join a Room</h2>
      <p class="desc">
        A room is a peer-to-peer network. The creator hosts the entry point.
        Once connected, everyone talks directly — no server in the middle.
      </p>
      <div style="display:flex; gap:0.75rem; flex-wrap:wrap;">
        <button onclick="createRoom()">Create New Room</button>
        <button class="secondary" onclick="document.getElementById('join-fields').classList.toggle('hidden')">Join Existing Room</button>
      </div>
      <div id="join-fields" class="hidden" style="margin-top:1rem;">
        <div class="field">
          <label for="join-id">Room code</label>
          <input type="text" id="join-id" placeholder="e.g. oak-river-7293">
        </div>
        <button onclick="joinRoom()">Connect</button>
      </div>
    </div>

    <!-- After connected -->
    <div id="room-info" class="room-banner hidden">
      <div>
        <div style="font-size:0.82rem; color:var(--text2);">Room</div>
        <div class="room-id" id="room-id-display"></div>
        <div class="room-meta" id="room-meta"></div>
      </div>
      <div class="room-actions">
        <button class="small secondary" onclick="copyLink()">Copy invite link</button>
        <button class="small secondary" onclick="toggleNetLog()">Network log</button>
      </div>
      <div class="net-log hidden" id="net-log" style="width:100%;"></div>
    </div>
  </section>

  <!-- ============================================================== -->
  <!-- ENROLLMENT / IDENTITY                                          -->
  <!-- ============================================================== -->
  <section id="sec-enroll" class="hidden">
    <div class="id-banner" id="id-banner">
      <div>
        <div class="meta">Identity</div>
        <div class="status not-enrolled" id="id-text">Not yet verified</div>
      </div>
      <button id="id-btn" onclick="toggleEnroll()">Verify Identity</button>
    </div>

    <div class="card hidden" id="enroll-card">
      <h2>Biometric Verification</h2>
      <p class="desc">
        Select at least 2 factors. In production, your device would scan real biometrics.
        The raw data never leaves your device — only a cryptographic key is shared with
        your peers for verification.
      </p>

      <div class="prog"><div class="bar" id="prog-bar" style="width:0%"></div></div>

      <div class="factors" id="factors">
        <div class="factor" data-f="fingerprint" onclick="pickFactor(this)">
          <div class="ic">&#9757;</div>
          <div class="nm">Fingerprint</div>
          <div class="check">&#10003; selected</div>
        </div>
        <div class="factor" data-f="face" onclick="pickFactor(this)">
          <div class="ic">&#128100;</div>
          <div class="nm">Face</div>
          <div class="check">&#10003; selected</div>
        </div>
        <div class="factor" data-f="iris" onclick="pickFactor(this)">
          <div class="ic">&#128065;</div>
          <div class="nm">Iris Scan</div>
          <div class="check">&#10003; selected</div>
        </div>
        <div class="factor" data-f="voice" onclick="pickFactor(this)">
          <div class="ic">&#127908;</div>
          <div class="nm">Voice</div>
          <div class="check">&#10003; selected</div>
        </div>
      </div>

      <button class="green full" id="enroll-btn" onclick="doEnroll()" disabled>
        Select at least 2 factors
      </button>
    </div>
  </section>

  <!-- ============================================================== -->
  <!-- CREATE TOPIC                                                   -->
  <!-- ============================================================== -->
  <section id="sec-create-topic" class="hidden">
    <div class="card">
      <h2>Create a Topic</h2>
      <p class="desc">Add a question or issue for the group to participate in.</p>
      <button class="secondary" onclick="document.getElementById('create-topic-form').classList.toggle('hidden')">
        + New Topic
      </button>
      <div id="create-topic-form" class="create-topic-form hidden">
        <div class="field">
          <label for="new-topic-title">Title</label>
          <input type="text" id="new-topic-title" placeholder="e.g. Should we adopt universal basic income?">
        </div>
        <div class="field">
          <label for="new-topic-desc">Description</label>
          <textarea id="new-topic-desc" rows="2" placeholder="Explain the issue..."></textarea>
        </div>
        <div class="field">
          <label for="new-topic-options">Vote options (comma-separated, leave blank for opinion-only)</label>
          <input type="text" id="new-topic-options" placeholder="e.g. Yes, No, Needs more research">
        </div>
        <button class="green" onclick="createTopic()">Create Topic</button>
      </div>
    </div>
  </section>

  <!-- ============================================================== -->
  <!-- TOPICS                                                         -->
  <!-- ============================================================== -->
  <section id="sec-topics" class="hidden">
    <h2 style="margin-bottom:0.75rem; font-size:1.15rem;">Open Topics</h2>
    <div id="topic-list"></div>
  </section>

  <!-- ============================================================== -->
  <!-- PARTICIPATE                                                    -->
  <!-- ============================================================== -->
  <section id="sec-participate" class="hidden">
    <div class="card">
      <h2 id="part-title"></h2>
      <p class="desc" id="part-desc"></p>

      <div class="tabs" id="part-tabs"></div>

      <div id="form-opinion" class="hidden">
        <div class="field">
          <label for="txt-opinion">Share your perspective</label>
          <textarea id="txt-opinion" rows="4" placeholder="What do you think about this issue?"></textarea>
        </div>
        <button class="green" onclick="send('opinion')">Submit Opinion</button>
      </div>

      <div id="form-idea" class="hidden">
        <div class="field">
          <label for="txt-idea">Propose a solution or approach</label>
          <textarea id="txt-idea" rows="4" placeholder="Describe your idea..."></textarea>
        </div>
        <button class="green" onclick="send('idea')">Submit Idea</button>
      </div>

      <div id="form-vote" class="hidden">
        <div class="field">
          <label for="sel-vote">Cast your vote</label>
          <select id="sel-vote"></select>
        </div>
        <button class="green" onclick="send('vote')">Cast Vote</button>
      </div>
    </div>

    <div class="card">
      <h2>What others have said</h2>
      <div id="sub-list">
        <p style="color:var(--text2); font-size:0.85rem;">
          No submissions yet. Be the first to participate.
        </p>
      </div>
    </div>
  </section>

  <!-- ============================================================== -->
  <!-- PRIVACY                                                        -->
  <!-- ============================================================== -->
  <div class="privacy" id="sec-privacy" style="display:none;">
    <strong>How your data is protected (P2P edition):</strong>
    Biometric scans are processed on your device only. A cryptographic key
    is generated locally and the public half is shared with peers so they can
    verify your submissions. All data is replicated across every connected browser —
    there is no central server to hack, shut down, or censor. If any
    peer goes offline, the remaining network still holds the complete record.
    One key per person means one vote per person.
    <br><br>
    <strong>Durable storage:</strong>
    All replicated data (enrollments, topics, submissions) is persisted to
    IndexedDB on your device. When you rejoin a room — even after closing
    the browser — your node rehydrates from local storage and shares what
    it knows with peers. Data propagation uses G-Set CRDTs (grow-only sets)
    with set-union merge, so there are no conflicts. The seen-set for
    message deduplication is capped at 10,000 entries to bound memory use.
  </div>
</div>

<footer>
  OpenDemocracy P2P &mdash; no server, no censorship, no single point of failure
  &middot; <a href="https://github.com/AshmanRoonz/OpenDemocracy" target="_blank">GitHub</a>
</footer>

<!-- PeerJS for WebRTC signaling -->
<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

<script>
/* ==================================================================
   OpenDemocracy — Peer-to-Peer Edition with Persistent Storage
   ==================================================================
   Architecture:
   - Every browser is both client AND server
   - WebRTC data channels (via PeerJS) connect peers directly
   - Full mesh: every peer connects to every other peer
   - State (enrollments, topics, submissions) replicated via gossip
   - Each peer independently verifies all cryptographic signatures
   - No central server — host on GitHub Pages, open from file://, anywhere
   -
   - PERSISTENCE (Phase 3):
   -   Data model: G-Set CRDTs (grow-only sets). Enrollments, topics,
   -   and submissions are append-only, keyed by unique IDs. The merge
   -   operation is set union — commutative, associative, idempotent.
   -   No conflicts possible.
   -
   -   Storage: IndexedDB for durable local persistence. Every mutation
   -   is written through to IndexedDB so state survives tab close,
   -   browser restart, and offline periods.
   -
   -   Sync: On peer connect, nodes exchange a compact state digest
   -   (counts per collection). If digests differ, only the missing
   -   entries are transmitted (anti-entropy). Real-time mutations
   -   still propagate via gossip broadcast.
   -
   -   Eviction: The seen-set (message dedup) is capped at 10,000
   -   entries with LRU eviction. Topics can be archived after a
   -   configurable age. Storage usage is monitored and displayed.
   -
   -   Why not IPFS/libp2p? Too heavy for Phase 3 — adds ~400KB of
   -   JS dependencies, requires DHT bootstrap nodes, and the data
   -   volumes here (text submissions) don't warrant content-addressed
   -   blob storage yet. IndexedDB + gossip gives us durable, offline-
   -   capable persistence with zero extra dependencies. IPFS is the
   -   right move for Phase 4 (planetary scale) when we need cross-
   -   room persistence and archival pinning.
   ================================================================== */

/* ==================================================================
   INDEXEDDB PERSISTENCE LAYER
   ================================================================== */

const DB_NAME = "opendemocracy_p2p";
const DB_VERSION = 1;
const STORES = ["enrollments", "topics", "submissions", "seen", "meta"];

const store = {
  db: null,

  open() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        for (const name of STORES) {
          if (!db.objectStoreNames.contains(name)) {
            db.createObjectStore(name);
          }
        }
      };
      req.onsuccess = (e) => {
        store.db = e.target.result;
        resolve(store.db);
      };
      req.onerror = (e) => {
        console.warn("IndexedDB open failed, running in-memory only:", e.target.error);
        resolve(null);
      };
    });
  },

  // Generic put: store a value by key in the named object store
  put(storeName, key, value) {
    if (!store.db) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const tx = store.db.transaction(storeName, "readwrite");
      tx.objectStore(storeName).put(value, key);
      tx.oncomplete = () => resolve();
      tx.onerror = (e) => { console.warn("IDB put error:", e.target.error); resolve(); };
    });
  },

  // Generic get: retrieve a value by key
  get(storeName, key) {
    if (!store.db) return Promise.resolve(undefined);
    return new Promise((resolve, reject) => {
      const tx = store.db.transaction(storeName, "readonly");
      const req = tx.objectStore(storeName).get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = (e) => { console.warn("IDB get error:", e.target.error); resolve(undefined); };
    });
  },

  // Get all entries from a store as [key, value] pairs
  getAll(storeName) {
    if (!store.db) return Promise.resolve([]);
    return new Promise((resolve, reject) => {
      const tx = store.db.transaction(storeName, "readonly");
      const os = tx.objectStore(storeName);
      const keys = [];
      const values = [];
      const kReq = os.getAllKeys();
      const vReq = os.getAll();
      tx.oncomplete = () => {
        const pairs = [];
        for (let i = 0; i < keys.length; i++) pairs.push([keys[i], values[i]]);
        resolve(pairs);
      };
      kReq.onsuccess = () => { keys.push(...kReq.result); };
      vReq.onsuccess = () => { values.push(...vReq.result); };
      tx.onerror = (e) => { console.warn("IDB getAll error:", e.target.error); resolve([]); };
    });
  },

  // Delete a key from a store
  del(storeName, key) {
    if (!store.db) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const tx = store.db.transaction(storeName, "readwrite");
      tx.objectStore(storeName).delete(key);
      tx.oncomplete = () => resolve();
      tx.onerror = (e) => { console.warn("IDB del error:", e.target.error); resolve(); };
    });
  },

  // Count entries in a store
  count(storeName) {
    if (!store.db) return Promise.resolve(0);
    return new Promise((resolve, reject) => {
      const tx = store.db.transaction(storeName, "readonly");
      const req = tx.objectStore(storeName).count();
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => resolve(0);
    });
  },

  // Bulk put for initial sync (batch write in a single transaction)
  putBatch(storeName, entries) {
    if (!store.db || !entries.length) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const tx = store.db.transaction(storeName, "readwrite");
      const os = tx.objectStore(storeName);
      for (const [key, value] of entries) {
        os.put(value, key);
      }
      tx.oncomplete = () => resolve();
      tx.onerror = (e) => { console.warn("IDB batch error:", e.target.error); resolve(); };
    });
  },

  // Estimate storage usage (bytes) — uses Storage API where available
  async estimateUsage() {
    if (navigator.storage && navigator.storage.estimate) {
      const est = await navigator.storage.estimate();
      return { used: est.usage || 0, quota: est.quota || 0 };
    }
    // Fallback: count entries
    const e = await store.count("enrollments");
    const t = await store.count("topics");
    const s = await store.count("submissions");
    return { used: (e + t + s) * 500, quota: 0, entries: e + t + s }; // rough estimate
  },
};

/* ==================================================================
   SEEN-SET WITH LRU EVICTION
   ================================================================== */

const SEEN_MAX = 10000;

const seenSet = {
  // Ordered map: msgId -> timestamp. Oldest entries evicted first.
  _map: new Map(),

  has(msgId) {
    return seenSet._map.has(msgId);
  },

  add(msgId) {
    if (seenSet._map.has(msgId)) return;
    seenSet._map.set(msgId, Date.now());
    // Evict oldest if over capacity
    if (seenSet._map.size > SEEN_MAX) {
      const oldest = seenSet._map.keys().next().value;
      seenSet._map.delete(oldest);
      store.del("seen", oldest);
    }
    // Persist (fire-and-forget)
    store.put("seen", msgId, Date.now());
  },

  get size() {
    return seenSet._map.size;
  },

  // Load from IndexedDB on boot
  async load() {
    const pairs = await store.getAll("seen");
    // Sort by timestamp ascending so oldest are first in map
    pairs.sort((a, b) => a[1] - b[1]);
    for (const [key, ts] of pairs) {
      seenSet._map.set(key, ts);
    }
    // Trim if DB had more than the cap
    while (seenSet._map.size > SEEN_MAX) {
      const oldest = seenSet._map.keys().next().value;
      seenSet._map.delete(oldest);
      store.del("seen", oldest);
    }
  },
};

/* ==================================================================
   P2P STATE
   ================================================================== */

const state = {
  roomId: null,
  isHost: false,
  myPeerId: null,
  peer: null,              // PeerJS instance
  connections: new Map(),  // peerId -> DataConnection
  peerList: [],            // known peer IDs

  // Replicated data (same on every peer) — G-Set CRDTs
  enrollments: new Map(),  // anonymous_id -> { public_key, factors, enrolled_at }
  topics: new Map(),       // topic_id -> { id, title, description, ... }
  submissions: new Map(),  // submission_id -> { id, topic_id, anonymous_id, type, content, signature, ... }

  // Persistence flag
  dbReady: false,
};

/* ---- Local identity (only on this browser) ---- */
let me = JSON.parse(localStorage.getItem("od_p2p_me") || "null");
let selectedFactors = [];
let currentTopic = null;
let currentTab = "opinion";

/* ==================================================================
   STATE HELPERS (write-through to IndexedDB)
   ================================================================== */

async function addEnrollment(id, data) {
  if (state.enrollments.has(id)) return false;
  state.enrollments.set(id, data);
  await store.put("enrollments", id, data);
  return true;
}

async function addTopic(id, data) {
  if (state.topics.has(id)) return false;
  state.topics.set(id, data);
  await store.put("topics", id, data);
  return true;
}

async function addSubmission(id, data) {
  if (state.submissions.has(id)) return false;
  state.submissions.set(id, data);
  await store.put("submissions", id, data);
  return true;
}

// Rehydrate in-memory state from IndexedDB
async function rehydrate() {
  const [enrollments, topics, submissions] = await Promise.all([
    store.getAll("enrollments"),
    store.getAll("topics"),
    store.getAll("submissions"),
    seenSet.load(),
  ]);

  let loaded = 0;
  for (const [id, data] of enrollments) {
    state.enrollments.set(id, data);
    loaded++;
  }
  for (const [id, data] of topics) {
    state.topics.set(id, data);
    loaded++;
  }
  for (const [id, data] of submissions) {
    state.submissions.set(id, data);
    loaded++;
  }

  state.dbReady = true;
  return loaded;
}

// Build a compact digest of our state for anti-entropy sync
function stateDigest() {
  return {
    enrollmentIds: [...state.enrollments.keys()],
    topicIds: [...state.topics.keys()],
    submissionIds: [...state.submissions.keys()],
  };
}

/* ==================================================================
   CRYPTO (all in-browser via Web Crypto API)
   ================================================================== */

async function generateKeypair() {
  // Generate HMAC key for signing (prototype — production would use Ed25519)
  const rawKey = new Uint8Array(32);
  crypto.getRandomValues(rawKey);
  const privateKey = bytesToHex(rawKey);
  const publicKey = bytesToHex(new Uint8Array(
    await crypto.subtle.digest("SHA-256", rawKey)
  ));
  return { privateKey, publicKey };
}

async function signMessage(publicKey, message) {
  // HMAC-SHA256 sign using public key (matches the server prototype's scheme)
  const enc = new TextEncoder();
  const key = await crypto.subtle.importKey(
    "raw", enc.encode(publicKey),
    { name: "HMAC", hash: "SHA-256" }, false, ["sign"]
  );
  const sig = await crypto.subtle.sign("HMAC", key, enc.encode(message));
  return bytesToHex(new Uint8Array(sig));
}

async function verifySignature(publicKey, message, signature) {
  const expected = await signMessage(publicKey, message);
  return expected === signature;
}

function generateId(len = 12) {
  const arr = new Uint8Array(len);
  crypto.getRandomValues(arr);
  return bytesToHex(arr).slice(0, len);
}

function bytesToHex(bytes) {
  return [...bytes].map(b => b.toString(16).padStart(2, "0")).join("");
}

/* ==================================================================
   ROOM MANAGEMENT
   ================================================================== */

const ADJECTIVES = ["red","blue","green","gold","oak","elm","iron","swift","calm","bold","warm","cool","deep","high","wild"];
const NOUNS = ["river","stone","cloud","flame","forge","tower","ridge","grove","storm","shore","field","moon","star","peak","wolf"];

function generateRoomId() {
  const a = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
  const n = NOUNS[Math.floor(Math.random() * NOUNS.length)];
  const d = Math.floor(Math.random() * 9000) + 1000;
  return `${a}-${n}-${d}`;
}

function createRoom() {
  const roomId = generateRoomId();
  state.roomId = roomId;
  state.isHost = true;
  initPeer(roomId);
}

function joinRoom() {
  let roomId = document.getElementById("join-id").value.trim();
  if (!roomId) { flash("Enter a room code.", "err"); return; }
  state.roomId = roomId;
  state.isHost = false;
  initPeer(null); // random peer ID, then connect to host
}

function initPeer(peerId) {
  // PeerJS uses its free cloud signaling server to establish WebRTC connections.
  // After the initial handshake, all data flows directly peer-to-peer.
  const opts = { debug: 0 };
  state.peer = peerId ? new Peer(peerId, opts) : new Peer(opts);

  state.peer.on("open", (id) => {
    state.myPeerId = id;
    netLog("Connected as: " + id, "ok");

    // Update URL hash for sharing
    if (state.isHost) {
      window.location.hash = state.roomId;
    }

    showRoomUI();

    // If not host, connect to the host
    if (!state.isHost) {
      connectToPeer(state.roomId);
    }
  });

  state.peer.on("connection", (conn) => {
    setupConnection(conn);
  });

  state.peer.on("error", (err) => {
    if (err.type === "unavailable-id") {
      flash("Room already exists. Try joining instead.", "err");
    } else if (err.type === "peer-unavailable") {
      flash("Could not reach room host. They may be offline.", "err");
    } else {
      netLog("Error: " + err.type + " — " + err.message, "err");
    }
  });
}

function connectToPeer(peerId) {
  if (peerId === state.myPeerId) return;
  if (state.connections.has(peerId)) return;

  netLog("Connecting to " + peerId + "...");
  const conn = state.peer.connect(peerId, { reliable: true });
  setupConnection(conn);
}

function setupConnection(conn) {
  conn.on("open", () => {
    state.connections.set(conn.peer, conn);
    netLog("Peer connected: " + conn.peer, "ok");
    updateStats();

    // Anti-entropy: send our digest first. The peer compares and requests
    // only the entries it's missing. Falls back to full sync if the peer
    // doesn't support digests (backwards compatible).
    conn.send({
      type: "digest",
      msgId: generateId(),
      digest: stateDigest(),
      peerList: [...state.connections.keys(), state.myPeerId],
    });
  });

  conn.on("data", (data) => handleMessage(data, conn.peer));

  conn.on("close", () => {
    state.connections.delete(conn.peer);
    netLog("Peer disconnected: " + conn.peer, "warn");
    updateStats();
  });

  conn.on("error", (err) => {
    netLog("Connection error with " + conn.peer + ": " + err, "err");
  });
}

/* ==================================================================
   GOSSIP PROTOCOL (with anti-entropy sync)
   ================================================================== */

function broadcast(msg) {
  // Tag every message with a unique ID for dedup
  if (!msg.msgId) msg.msgId = generateId(16);
  seenSet.add(msg.msgId);

  for (const [, conn] of state.connections) {
    try { conn.send(msg); } catch (_) { /* peer may have disconnected */ }
  }
}

async function handleMessage(msg, fromPeer) {
  // Dedup: ignore messages we've already seen
  if (msg.msgId && seenSet.has(msg.msgId)) return;
  if (msg.msgId) seenSet.add(msg.msgId);

  switch (msg.type) {
    case "digest":
      await handleDigest(msg, fromPeer);
      break;
    case "digest-request":
      await handleDigestRequest(msg, fromPeer);
      break;
    case "sync":
      await handleSync(msg, fromPeer);
      break;
    case "enroll":
      await handleEnrollMsg(msg);
      break;
    case "topic":
      await handleTopicMsg(msg);
      break;
    case "submit":
      await handleSubmitMsg(msg);
      break;
  }
}

// Anti-entropy: receive a peer's digest and compute what they need
async function handleDigest(msg, fromPeer) {
  netLog("Digest from " + fromPeer + " — comparing state", "ok");
  const remote = msg.digest;
  const remoteEnrollIds = new Set(remote.enrollmentIds);
  const remoteTopicIds = new Set(remote.topicIds);
  const remoteSubIds = new Set(remote.submissionIds);

  // What we have that they don't
  const missingEnrollments = [];
  for (const [id, data] of state.enrollments) {
    if (!remoteEnrollIds.has(id)) missingEnrollments.push([id, data]);
  }
  const missingTopics = [];
  for (const [id, data] of state.topics) {
    if (!remoteTopicIds.has(id)) missingTopics.push([id, data]);
  }
  const missingSubmissions = [];
  for (const [id, data] of state.submissions) {
    if (!remoteSubIds.has(id)) missingSubmissions.push([id, data]);
  }

  const conn = state.connections.get(fromPeer);
  if (!conn) return;

  // Send them what they're missing
  if (missingEnrollments.length || missingTopics.length || missingSubmissions.length) {
    netLog("Sending " + (missingEnrollments.length + missingTopics.length + missingSubmissions.length) + " missing entries to " + fromPeer, "ok");
    conn.send({
      type: "sync",
      msgId: generateId(),
      enrollments: missingEnrollments,
      topics: missingTopics,
      submissions: missingSubmissions,
      peerList: [...state.connections.keys(), state.myPeerId],
    });
  }

  // What they have that we don't — request it
  const weNeedEnrollIds = remote.enrollmentIds.filter(id => !state.enrollments.has(id));
  const weNeedTopicIds = remote.topicIds.filter(id => !state.topics.has(id));
  const weNeedSubIds = remote.submissionIds.filter(id => !state.submissions.has(id));

  if (weNeedEnrollIds.length || weNeedTopicIds.length || weNeedSubIds.length) {
    netLog("Requesting " + (weNeedEnrollIds.length + weNeedTopicIds.length + weNeedSubIds.length) + " missing entries from " + fromPeer, "ok");
    conn.send({
      type: "digest-request",
      msgId: generateId(),
      enrollmentIds: weNeedEnrollIds,
      topicIds: weNeedTopicIds,
      submissionIds: weNeedSubIds,
    });
  }

  // Connect to peers we don't know yet
  for (const peerId of (msg.peerList || [])) {
    if (peerId !== state.myPeerId && !state.connections.has(peerId)) {
      connectToPeer(peerId);
    }
  }
}

// Handle a request for specific entries by ID
async function handleDigestRequest(msg, fromPeer) {
  const conn = state.connections.get(fromPeer);
  if (!conn) return;

  const enrollments = (msg.enrollmentIds || [])
    .filter(id => state.enrollments.has(id))
    .map(id => [id, state.enrollments.get(id)]);
  const topics = (msg.topicIds || [])
    .filter(id => state.topics.has(id))
    .map(id => [id, state.topics.get(id)]);
  const submissions = (msg.submissionIds || [])
    .filter(id => state.submissions.has(id))
    .map(id => [id, state.submissions.get(id)]);

  if (enrollments.length || topics.length || submissions.length) {
    conn.send({
      type: "sync",
      msgId: generateId(),
      enrollments,
      topics,
      submissions,
      peerList: [...state.connections.keys(), state.myPeerId],
    });
  }
}

async function handleSync(msg, fromPeer) {
  netLog("State sync from " + fromPeer, "ok");
  let added = 0;

  // Merge enrollments (write-through to IndexedDB)
  const newEnrollments = [];
  for (const [id, data] of msg.enrollments) {
    if (!state.enrollments.has(id)) {
      state.enrollments.set(id, data);
      newEnrollments.push([id, data]);
      added++;
    }
  }
  if (newEnrollments.length) await store.putBatch("enrollments", newEnrollments);

  // Merge topics
  const newTopics = [];
  for (const [id, data] of msg.topics) {
    if (!state.topics.has(id)) {
      state.topics.set(id, data);
      newTopics.push([id, data]);
      added++;
    }
  }
  if (newTopics.length) await store.putBatch("topics", newTopics);

  // Merge submissions (verify each one)
  const newSubmissions = [];
  for (const [id, data] of msg.submissions) {
    if (!state.submissions.has(id)) {
      const enrollment = state.enrollments.get(data.anonymous_id);
      if (enrollment) {
        const valid = await verifySignature(
          enrollment.public_key, data.nonce, data.signature
        );
        if (valid) {
          state.submissions.set(id, data);
          newSubmissions.push([id, data]);
          added++;
        } else {
          netLog("Rejected invalid submission " + id, "warn");
        }
      }
    }
  }
  if (newSubmissions.length) await store.putBatch("submissions", newSubmissions);

  if (added > 0) {
    netLog("Merged " + added + " new entries from " + fromPeer, "ok");
  }

  // Connect to peers we don't know yet
  for (const peerId of (msg.peerList || [])) {
    if (peerId !== state.myPeerId && !state.connections.has(peerId)) {
      connectToPeer(peerId);
    }
  }

  refreshAll();
  updateStorageStats();
}

async function handleEnrollMsg(msg) {
  const added = await addEnrollment(msg.anonymous_id, {
    public_key: msg.public_key,
    factors: msg.factors,
    enrolled_at: msg.enrolled_at,
  });
  if (!added) return;
  // Re-gossip to peers who may not have seen it
  broadcast(msg);
  refreshAll();
  updateStorageStats();
}

async function handleTopicMsg(msg) {
  const added = await addTopic(msg.topic.id, msg.topic);
  if (!added) return;
  broadcast(msg);
  refreshAll();
  updateStorageStats();
}

async function handleSubmitMsg(msg) {
  if (state.submissions.has(msg.submission.id)) return;

  // Verify the signature before accepting
  const enrollment = state.enrollments.get(msg.submission.anonymous_id);
  if (!enrollment) {
    netLog("Rejected submission from unknown identity", "warn");
    return;
  }

  const valid = await verifySignature(
    enrollment.public_key,
    msg.submission.nonce,
    msg.submission.signature
  );
  if (!valid) {
    netLog("Rejected submission with invalid signature", "warn");
    return;
  }

  // Check one-person-one-vote per topic+type
  for (const [, sub] of state.submissions) {
    if (sub.topic_id === msg.submission.topic_id &&
        sub.anonymous_id === msg.submission.anonymous_id &&
        sub.submission_type === msg.submission.submission_type) {
      netLog("Rejected duplicate submission", "warn");
      return;
    }
  }

  await addSubmission(msg.submission.id, msg.submission);
  broadcast(msg);
  refreshAll();
  updateStorageStats();
}

/* ==================================================================
   LOCAL ACTIONS
   ================================================================== */

async function doEnroll() {
  const btn = document.getElementById("enroll-btn");
  btn.disabled = true;
  btn.textContent = "Scanning biometrics...";
  await pause(1200);
  btn.textContent = "Generating cryptographic key...";
  await pause(600);

  const { privateKey, publicKey } = await generateKeypair();
  const anonymousId = generateId(16);
  const factorNames = [...selectedFactors];

  const enrollment = {
    public_key: publicKey,
    factors: factorNames,
    enrolled_at: new Date().toISOString(),
  };
  await addEnrollment(anonymousId, enrollment);

  // Save locally (private key NEVER leaves this browser)
  me = {
    anonymous_id: anonymousId,
    public_key: publicKey,
    private_key: privateKey,
    factors_enrolled: factorNames,
  };
  localStorage.setItem("od_p2p_me", JSON.stringify(me));

  // Broadcast enrollment to all peers
  broadcast({
    type: "enroll",
    anonymous_id: anonymousId,
    public_key: publicKey,
    factors: factorNames,
    enrolled_at: enrollment.enrolled_at,
  });

  refreshIdentity();
  updateStats();
  updateStorageStats();
  flash("Identity verified. Your private key is stored only in this browser.", "ok");
}

async function createTopic() {
  const title = document.getElementById("new-topic-title").value.trim();
  const desc = document.getElementById("new-topic-desc").value.trim();
  const optStr = document.getElementById("new-topic-options").value.trim();
  if (!title) { flash("Enter a topic title.", "err"); return; }

  const voteOptions = optStr ? optStr.split(",").map(s => s.trim()).filter(Boolean) : [];
  const topic = {
    id: generateId(12),
    title,
    description: desc,
    allow_opinions: true,
    allow_ideas: true,
    allow_votes: voteOptions.length > 0,
    vote_options: voteOptions,
    created_at: new Date().toISOString(),
  };

  await addTopic(topic.id, topic);
  broadcast({ type: "topic", topic });

  // Clear form
  document.getElementById("new-topic-title").value = "";
  document.getElementById("new-topic-desc").value = "";
  document.getElementById("new-topic-options").value = "";
  document.getElementById("create-topic-form").classList.add("hidden");

  refreshAll();
  updateStorageStats();
  flash("Topic created and shared with all peers.", "ok");
}

async function send(type) {
  if (!me) { flash("You must verify your identity first.", "err"); return; }
  if (!currentTopic) return;

  let content = "";
  if (type === "opinion") content = document.getElementById("txt-opinion").value.trim();
  else if (type === "idea") content = document.getElementById("txt-idea").value.trim();
  else if (type === "vote") content = document.getElementById("sel-vote").value;
  if (!content) { flash("Please enter your " + type + " first.", "err"); return; }

  // Check if already submitted this type for this topic
  for (const [, sub] of state.submissions) {
    if (sub.topic_id === currentTopic.id &&
        sub.anonymous_id === me.anonymous_id &&
        sub.submission_type === type) {
      flash("You already submitted a " + type + " for this topic.", "err");
      return;
    }
  }

  // Generate a nonce and sign it
  const nonce = generateId(32);
  const signature = await signMessage(me.public_key, nonce);

  const submission = {
    id: generateId(12),
    topic_id: currentTopic.id,
    anonymous_id: me.anonymous_id,
    submission_type: type,
    content,
    nonce,
    signature,
    submitted_at: new Date().toISOString(),
  };

  await addSubmission(submission.id, submission);
  broadcast({ type: "submit", submission });

  if (type === "opinion") document.getElementById("txt-opinion").value = "";
  if (type === "idea") document.getElementById("txt-idea").value = "";
  refreshAll();
  updateStorageStats();
  flash(type.charAt(0).toUpperCase() + type.slice(1) + " submitted and broadcast to all peers.", "ok");
}

/* ==================================================================
   UI
   ================================================================== */

async function showRoomUI() {
  document.getElementById("room-setup").classList.add("hidden");
  document.getElementById("room-info").classList.remove("hidden");
  document.getElementById("room-id-display").textContent = state.roomId;
  document.getElementById("room-meta").textContent =
    state.isHost ? "You are the host (entry point for new peers)" : "Connected to room";

  // Show remaining sections
  document.getElementById("sec-enroll").classList.remove("hidden");
  document.getElementById("sec-create-topic").classList.remove("hidden");
  document.getElementById("sec-topics").classList.remove("hidden");
  document.getElementById("sec-privacy").style.display = "";

  // If already enrolled from a previous session, restore identity
  if (me) {
    // Re-register our enrollment in the local state (and persist)
    if (!state.enrollments.has(me.anonymous_id)) {
      const enrollment = {
        public_key: me.public_key,
        factors: me.factors_enrolled,
        enrolled_at: new Date().toISOString(),
      };
      await addEnrollment(me.anonymous_id, enrollment);
      broadcast({
        type: "enroll",
        anonymous_id: me.anonymous_id,
        public_key: me.public_key,
        factors: me.factors_enrolled,
        enrolled_at: enrollment.enrolled_at,
      });
    }
  }

  refreshIdentity();
  refreshAll();
  updateStorageStats();
}

function refreshIdentity() {
  const txt = document.getElementById("id-text");
  const btn = document.getElementById("id-btn");
  if (me) {
    txt.textContent = "Verified (" + me.factors_enrolled.join(", ") + ")";
    txt.className = "status enrolled";
    btn.textContent = "Verified";
    btn.disabled = true;
    btn.className = "secondary";
    document.getElementById("enroll-card").classList.add("hidden");
  } else {
    txt.textContent = "Not yet verified";
    txt.className = "status not-enrolled";
    btn.textContent = "Verify Identity";
    btn.disabled = false;
  }
}

function toggleEnroll() {
  document.getElementById("enroll-card").classList.toggle("hidden");
}

function pickFactor(el) {
  const f = el.dataset.f;
  el.classList.toggle("on");
  selectedFactors = [...document.querySelectorAll(".factor.on")].map(e => e.dataset.f);
  const pct = Math.min((selectedFactors.length / 2) * 100, 100);
  document.getElementById("prog-bar").style.width = pct + "%";
  const btn = document.getElementById("enroll-btn");
  btn.disabled = selectedFactors.length < 2;
  btn.textContent = selectedFactors.length < 2
    ? "Select at least 2 factors"
    : "Verify with " + selectedFactors.join(" + ");
}

function refreshAll() {
  renderTopics();
  if (currentTopic) renderSubmissions(currentTopic.id);
  updateStats();
}

function renderTopics() {
  const el = document.getElementById("topic-list");
  const topics = [...state.topics.values()];
  if (!topics.length) {
    el.innerHTML = '<p style="color:var(--text2)">No topics yet. Create one above.</p>';
    return;
  }
  el.innerHTML = topics.map(t =>
    '<div class="card topic' + (currentTopic && currentTopic.id === t.id ? ' on' : '') +
    '" onclick="openTopic(\'' + t.id + '\')">' +
    '<h3>' + esc(t.title) + '</h3>' +
    '<p class="desc">' + esc(t.description) + '</p>' +
    '</div>'
  ).join("");
}

function openTopic(id) {
  const t = state.topics.get(id);
  if (!t) return;
  currentTopic = t;

  document.querySelectorAll(".topic").forEach(el => {
    el.classList.toggle("on", el.querySelector("h3").textContent === t.title);
  });

  document.getElementById("sec-participate").classList.remove("hidden");
  document.getElementById("part-title").textContent = t.title;
  document.getElementById("part-desc").textContent = t.description;

  const allowed = [];
  if (t.allow_opinions) allowed.push("opinion");
  if (t.allow_ideas) allowed.push("idea");
  if (t.allow_votes) allowed.push("vote");
  document.getElementById("part-tabs").innerHTML = allowed.map(x =>
    '<div class="tab" onclick="setTab(\'' + x + '\')">' +
    x.charAt(0).toUpperCase() + x.slice(1) +
    '</div>'
  ).join("");
  if (allowed.length) setTab(allowed[0]);

  if (t.vote_options && t.vote_options.length) {
    document.getElementById("sel-vote").innerHTML =
      t.vote_options.map(o => '<option value="' + esc(o) + '">' + esc(o) + '</option>').join("");
  }

  renderSubmissions(id);
}

function setTab(t) {
  currentTab = t;
  document.querySelectorAll(".tab").forEach(el =>
    el.classList.toggle("on", el.textContent.toLowerCase() === t)
  );
  document.getElementById("form-opinion").classList.toggle("hidden", t !== "opinion");
  document.getElementById("form-idea").classList.toggle("hidden", t !== "idea");
  document.getElementById("form-vote").classList.toggle("hidden", t !== "vote");
}

function renderSubmissions(topicId) {
  const subs = [...state.submissions.values()].filter(s => s.topic_id === topicId);
  const el = document.getElementById("sub-list");
  if (!subs.length) {
    el.innerHTML = '<p style="color:var(--text2); font-size:0.85rem;">No submissions yet. Be the first.</p>';
    return;
  }
  el.innerHTML = subs.map(s =>
    '<div class="sub-item">' +
    '<span class="badge badge-' + s.submission_type + '">' + s.submission_type + '</span>' +
    esc(s.content) +
    '</div>'
  ).join("");
}

function updateStats() {
  document.getElementById("st-peers").textContent = state.connections.size;
  document.getElementById("st-enrolled").textContent = state.enrollments.size;
  document.getElementById("st-subs").textContent = state.submissions.size;

  const dot = document.getElementById("net-dot");
  dot.className = state.connections.size > 0 ? "peer-dot" : "peer-dot off";
}

async function updateStorageStats() {
  const usage = await store.estimateUsage();
  const el = document.getElementById("st-storage");
  if (usage.quota > 0) {
    const pct = ((usage.used / usage.quota) * 100).toFixed(1);
    const usedMB = (usage.used / 1024 / 1024).toFixed(1);
    el.innerHTML = 'Storage: <strong title="' + usedMB + ' MB used">' + pct + '%</strong>';
  } else if (usage.entries !== undefined) {
    el.innerHTML = 'Storage: <strong>' + usage.entries + ' entries</strong>';
  } else {
    el.innerHTML = 'Storage: <strong>active</strong>';
  }
}

function copyLink() {
  const url = window.location.origin + window.location.pathname + "#" + state.roomId;
  navigator.clipboard.writeText(url).then(() => {
    flash("Invite link copied to clipboard.", "ok");
  }).catch(() => {
    flash("Link: " + url, "ok");
  });
}

/* ---- Network log ---- */
function toggleNetLog() {
  document.getElementById("net-log").classList.toggle("hidden");
}

function netLog(msg, cls) {
  const el = document.getElementById("net-log");
  if (!el) return;
  const div = document.createElement("div");
  div.textContent = new Date().toLocaleTimeString() + " " + msg;
  if (cls) div.className = cls;
  el.appendChild(div);
  el.scrollTop = el.scrollHeight;

  // Keep log from growing too large
  while (el.children.length > 100) el.removeChild(el.firstChild);
}

/* ---- Helpers ---- */
function flash(msg, type) {
  const el = document.getElementById("alert");
  el.textContent = msg;
  el.className = "alert " + type;
  el.scrollIntoView({ behavior: "smooth", block: "nearest" });
  setTimeout(() => { el.className = "alert"; }, 6000);
}

function esc(s) {
  const d = document.createElement("div");
  d.textContent = s;
  return d.innerHTML;
}

function pause(ms) { return new Promise(r => setTimeout(r, ms)); }

/* ==================================================================
   BOOT — open IndexedDB, rehydrate state, then check for auto-join
   ================================================================== */

document.addEventListener("DOMContentLoaded", async () => {
  // 1. Open IndexedDB
  await store.open();
  if (store.db) {
    netLog("IndexedDB opened: " + DB_NAME, "ok");
  } else {
    netLog("IndexedDB unavailable — running in-memory only", "warn");
  }

  // 2. Rehydrate state from durable storage
  const loaded = await rehydrate();
  if (loaded > 0) {
    netLog("Rehydrated " + loaded + " entries from IndexedDB", "ok");
    refreshAll();
  }

  // 3. Update storage display
  await updateStorageStats();

  // 4. Check URL hash for auto-join
  const hash = window.location.hash.slice(1);
  if (hash) {
    document.getElementById("join-id").value = hash;
    joinRoom();
  }
});
</script>
</body>
</html>
