<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OpenDemocracy — Peer-to-Peer</title>
<style>
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface2: #242836;
    --border: #2e3345;
    --text: #e4e6f0;
    --text2: #9196ab;
    --accent: #6c8cff;
    --accent2: #4a6adf;
    --green: #4caf87;
    --green2: #3a9070;
    --red: #e05555;
    --orange: #e0993a;
    --radius: 12px;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.6;
    min-height: 100vh;
  }

  /* ---- Header ---- */
  header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 0.8rem 2rem;
    display: flex; align-items: center; justify-content: space-between;
    position: sticky; top: 0; z-index: 100;
    flex-wrap: wrap; gap: 0.5rem;
  }
  .logo { font-size: 1.2rem; font-weight: 700; letter-spacing: -0.02em; }
  .logo span { color: var(--accent); }
  .logo small { font-size: 0.7rem; font-weight: 400; color: var(--green); margin-left: 0.5rem; letter-spacing: 0.02em; }
  .header-stats { display: flex; gap: 1.5rem; font-size: 0.8rem; color: var(--text2); }
  .header-stats strong { color: var(--accent); font-weight: 600; }

  /* ---- Layout ---- */
  .container { max-width: 880px; margin: 0 auto; padding: 0 1.5rem; }
  section { margin-bottom: 2.5rem; }

  /* ---- Hero ---- */
  .hero { text-align: center; padding: 3rem 1rem 2rem; }
  .hero h2 {
    font-size: 2rem; font-weight: 700; letter-spacing: -0.03em;
    margin-bottom: 0.75rem; line-height: 1.2;
  }
  .hero h2 em { font-style: normal; color: var(--accent); }
  .hero p { color: var(--text2); font-size: 1.05rem; max-width: 560px; margin: 0 auto 1.5rem; }

  /* ---- Steps ---- */
  .steps {
    display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1rem; margin-bottom: 0.5rem;
  }
  .step {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 1.25rem; text-align: center;
  }
  .step .num {
    display: inline-block; width: 2rem; height: 2rem; line-height: 2rem;
    background: var(--accent); color: #fff; border-radius: 50%;
    font-size: 0.85rem; font-weight: 700; margin-bottom: 0.6rem;
  }
  .step h3 { font-size: 0.95rem; margin-bottom: 0.3rem; }
  .step p { font-size: 0.8rem; color: var(--text2); margin: 0; }

  /* ---- Cards ---- */
  .card {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 1.5rem; margin-bottom: 1rem;
  }
  .card h2 { font-size: 1.1rem; margin-bottom: 0.4rem; }
  .card p.desc { color: var(--text2); font-size: 0.9rem; margin-bottom: 1rem; }

  /* ---- Buttons ---- */
  button {
    background: var(--accent); color: #fff; border: none;
    border-radius: 8px; padding: 0.6rem 1.4rem;
    font-size: 0.9rem; font-weight: 500; cursor: pointer;
    transition: background 0.15s;
  }
  button:hover { background: var(--accent2); }
  button:disabled { opacity: 0.35; cursor: not-allowed; }
  button.green { background: var(--green); }
  button.green:hover { background: var(--green2); }
  button.secondary {
    background: var(--surface2); border: 1px solid var(--border); color: var(--text);
  }
  button.secondary:hover { background: var(--border); }
  button.full { width: 100%; }
  button.small { padding: 0.35rem 0.8rem; font-size: 0.8rem; }

  /* ---- Room banner ---- */
  .room-banner {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 1.25rem 1.5rem;
    margin-bottom: 1.5rem;
  }
  .room-banner .room-id {
    font-family: monospace; font-size: 1.1rem; font-weight: 700;
    color: var(--accent); letter-spacing: 0.03em;
  }
  .room-banner .room-meta { font-size: 0.82rem; color: var(--text2); margin-top: 0.3rem; }
  .room-actions { display: flex; gap: 0.5rem; margin-top: 0.75rem; flex-wrap: wrap; }

  /* ---- Peer indicator ---- */
  .peer-dot {
    display: inline-block; width: 8px; height: 8px; border-radius: 50%;
    background: var(--green); margin-right: 4px; vertical-align: middle;
  }
  .peer-dot.off { background: var(--red); }

  /* ---- Identity banner ---- */
  .id-banner {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 1.25rem 1.5rem;
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 1.5rem; gap: 1rem; flex-wrap: wrap;
  }
  .id-banner .meta { font-size: 0.85rem; color: var(--text2); }
  .id-banner .status { font-weight: 600; font-size: 0.95rem; }
  .enrolled { color: var(--green); }
  .not-enrolled { color: var(--orange); }

  /* ---- Biometric factors ---- */
  .factors {
    display: grid; grid-template-columns: repeat(4, 1fr);
    gap: 0.75rem; margin-bottom: 1.25rem;
  }
  @media (max-width: 500px) { .factors { grid-template-columns: repeat(2, 1fr); } }
  .factor {
    background: var(--surface2); border: 2px solid var(--border);
    border-radius: 10px; padding: 1rem 0.5rem;
    text-align: center; cursor: pointer; transition: all 0.15s; user-select: none;
  }
  .factor:hover { border-color: var(--accent); color: var(--text); }
  .factor.on {
    border-color: var(--green); background: rgba(76, 175, 135, 0.08); color: var(--text);
  }
  .factor .ic { font-size: 2rem; margin-bottom: 0.2rem; }
  .factor .nm { font-size: 0.8rem; font-weight: 500; color: var(--text2); }
  .factor.on .nm { color: var(--green); }
  .factor .check { display: none; font-size: 0.7rem; color: var(--green); }
  .factor.on .check { display: block; }

  /* ---- Progress bar ---- */
  .prog { height: 4px; background: var(--border); border-radius: 2px; margin-bottom: 1rem; overflow: hidden; }
  .prog .bar { height: 100%; background: var(--green); border-radius: 2px; transition: width 0.4s ease; }

  /* ---- Forms ---- */
  textarea, select, input[type="text"] {
    width: 100%; background: var(--surface2);
    border: 1px solid var(--border); border-radius: 8px;
    padding: 0.7rem 1rem; color: var(--text);
    font-size: 0.9rem; font-family: inherit; resize: vertical;
  }
  textarea:focus, select:focus, input:focus { outline: none; border-color: var(--accent); }
  label { display: block; font-size: 0.8rem; font-weight: 500; color: var(--text2); margin-bottom: 0.35rem; }
  .field { margin-bottom: 1rem; }

  /* ---- Tabs ---- */
  .tabs { display: flex; gap: 0.5rem; margin-bottom: 1.25rem; }
  .tab {
    padding: 0.45rem 1rem; background: var(--surface2);
    border: 1px solid var(--border); border-radius: 8px;
    font-size: 0.8rem; cursor: pointer; color: var(--text2); transition: all 0.15s;
  }
  .tab:hover { color: var(--text); }
  .tab.on { background: var(--accent); border-color: var(--accent); color: #fff; }

  /* ---- Submissions ---- */
  .sub-item {
    background: var(--surface2); border-radius: 8px;
    padding: 0.7rem 1rem; margin-bottom: 0.5rem; font-size: 0.9rem;
  }
  .badge {
    display: inline-block; font-size: 0.7rem; font-weight: 600;
    padding: 0.12rem 0.45rem; border-radius: 4px; margin-right: 0.5rem;
    text-transform: uppercase; letter-spacing: 0.02em;
  }
  .badge-opinion { background: rgba(108,140,255,0.2); color: var(--accent); }
  .badge-idea { background: rgba(224,153,58,0.2); color: var(--orange); }
  .badge-vote { background: rgba(76,175,135,0.2); color: var(--green); }

  /* ---- Topic list ---- */
  .topic { cursor: pointer; transition: border-color 0.15s; }
  .topic:hover { border-color: var(--accent); }
  .topic.on { border-color: var(--accent); background: rgba(108,140,255,0.04); }
  .topic h3 { font-size: 1rem; margin-bottom: 0.25rem; }
  .topic p { margin: 0; }

  /* ---- Alert ---- */
  .alert { padding: 0.7rem 1rem; border-radius: 8px; font-size: 0.85rem; margin-bottom: 1rem; display: none; }
  .alert.ok { background: rgba(76,175,135,0.12); color: var(--green); display: block; }
  .alert.err { background: rgba(224,85,85,0.12); color: var(--red); display: block; }

  /* ---- Privacy ---- */
  .privacy {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 1.25rem 1.5rem;
    margin-bottom: 2rem; font-size: 0.85rem; color: var(--text2); line-height: 1.7;
  }
  .privacy strong { color: var(--text); }

  .hidden { display: none !important; }

  footer {
    text-align: center; padding: 2rem 1rem;
    color: var(--text2); font-size: 0.78rem;
    border-top: 1px solid var(--border);
  }
  footer a { color: var(--accent); text-decoration: none; }

  /* ---- Create topic form ---- */
  .create-topic-form { margin-top: 1rem; }
  .create-topic-form .field { margin-bottom: 0.75rem; }

  /* ---- Network log ---- */
  .net-log {
    font-family: monospace; font-size: 0.75rem; color: var(--text2);
    background: var(--surface2); border-radius: 8px;
    padding: 0.75rem 1rem; max-height: 120px; overflow-y: auto;
    margin-top: 0.75rem;
  }
  .net-log div { margin-bottom: 2px; }
  .net-log .ok { color: var(--green); }
  .net-log .warn { color: var(--orange); }
  .net-log .err { color: var(--red); }

  /* ---- Analysis panel ---- */
  .analysis-panel {
    border: 1px solid var(--accent);
    border-radius: var(--radius);
    background: var(--surface);
    padding: 1.5rem;
    margin-bottom: 1.5rem;
  }
  .analysis-panel h2 {
    font-size: 1.15rem;
    margin-bottom: 0.3rem;
    color: var(--accent);
  }
  .analysis-panel .subtitle {
    font-size: 0.82rem;
    color: var(--text2);
    margin-bottom: 1.25rem;
  }
  .analysis-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
    margin-bottom: 1.25rem;
  }
  @media (max-width: 600px) { .analysis-grid { grid-template-columns: 1fr; } }
  .analysis-box {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 1rem;
  }
  .analysis-box h3 {
    font-size: 0.85rem;
    color: var(--text2);
    text-transform: uppercase;
    letter-spacing: 0.04em;
    margin-bottom: 0.6rem;
  }
  /* Horizontal bar chart rows */
  .bar-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.4rem;
    font-size: 0.82rem;
  }
  .bar-label {
    min-width: 70px;
    text-align: right;
    color: var(--text2);
    flex-shrink: 0;
  }
  .bar-track {
    flex: 1;
    height: 14px;
    background: var(--border);
    border-radius: 3px;
    overflow: hidden;
    position: relative;
  }
  .bar-fill {
    height: 100%;
    border-radius: 3px;
    transition: width 0.5s ease;
  }
  .bar-fill.support { background: var(--green); }
  .bar-fill.oppose { background: var(--red); }
  .bar-fill.neutral { background: var(--orange); }
  .bar-fill.urgency { background: #e06090; }
  .bar-fill.certainty { background: var(--accent); }
  .bar-value {
    min-width: 36px;
    text-align: left;
    color: var(--text);
    font-weight: 500;
  }
  /* Cluster cards */
  .cluster-card {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.85rem 1rem;
    margin-bottom: 0.6rem;
  }
  .cluster-card h4 {
    font-size: 0.88rem;
    font-weight: 600;
    margin-bottom: 0.3rem;
  }
  .cluster-card .cluster-size {
    font-size: 0.75rem;
    color: var(--text2);
    margin-bottom: 0.4rem;
  }
  .cluster-card .cluster-rep {
    font-size: 0.82rem;
    color: var(--text2);
    font-style: italic;
    border-left: 2px solid var(--border);
    padding-left: 0.6rem;
    margin-top: 0.35rem;
  }
  /* Bias warnings */
  .bias-warning {
    background: rgba(224,85,85,0.08);
    border: 1px solid rgba(224,85,85,0.3);
    border-radius: 8px;
    padding: 0.6rem 0.9rem;
    font-size: 0.82rem;
    color: var(--red);
    margin-bottom: 0.4rem;
  }
  /* Consensus meter */
  .consensus-meter {
    display: flex;
    height: 22px;
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 0.6rem;
  }
  .consensus-meter .seg {
    transition: width 0.5s ease;
    min-width: 2px;
  }
  .consensus-label {
    display: flex;
    justify-content: space-between;
    font-size: 0.75rem;
    color: var(--text2);
    margin-bottom: 0.6rem;
  }
  .analysis-empty {
    text-align: center;
    color: var(--text2);
    font-size: 0.88rem;
    padding: 1.5rem;
  }
</style>
</head>
<body>

<!-- ================================================================ -->
<!-- HEADER                                                           -->
<!-- ================================================================ -->
<header>
  <div class="logo"><span>Open</span>Democracy<small>P2P</small></div>
  <div class="header-stats">
    <span><span class="peer-dot" id="net-dot"></span> Peers: <strong id="st-peers">0</strong></span>
    <span>Verified: <strong id="st-enrolled">0</strong></span>
    <span>Submissions: <strong id="st-subs">0</strong></span>
    <span title="IndexedDB persistence" id="st-storage">Storage: <strong>--</strong></span>
  </div>
</header>

<div class="container">

  <!-- ============================================================== -->
  <!-- HERO                                                           -->
  <!-- ============================================================== -->
  <div class="hero">
    <h2>Your voice. <em>Verified.</em><br>No server needed.</h2>
    <p>Peer-to-peer democracy. Every browser is the server.
       One global mesh — open it, participate, and your voice joins humanity's shared record.</p>
  </div>

  <!-- ============================================================== -->
  <!-- HOW IT WORKS                                                   -->
  <!-- ============================================================== -->
  <section>
    <div class="steps">
      <div class="step">
        <div class="num">1</div>
        <h3>Open the page</h3>
        <p>Your browser joins the global mesh automatically.</p>
      </div>
      <div class="step">
        <div class="num">2</div>
        <h3>Verify your identity</h3>
        <p>Biometric scan on your device. Keys stay local.</p>
      </div>
      <div class="step">
        <div class="num">3</div>
        <h3>Participate</h3>
        <p>Submit opinions, ideas, or votes — replicated to all peers.</p>
      </div>
      <div class="step">
        <div class="num">4</div>
        <h3>AI analyzes collectively</h3>
        <p>Every browser runs sentiment, clustering, and bias detection locally.</p>
      </div>
    </div>
  </section>

  <!-- alert -->
  <div class="alert" id="alert"></div>

  <!-- ============================================================== -->
  <!-- NETWORK STATUS                                                 -->
  <!-- ============================================================== -->
  <section id="sec-room">
    <div id="room-info" class="room-banner">
      <div>
        <div style="font-size:0.82rem; color:var(--text2);">Network</div>
        <div class="room-id" id="room-id-display">Connecting...</div>
        <div class="room-meta" id="room-meta">Joining the global mesh</div>
      </div>
      <div class="room-actions">
        <button class="small secondary" onclick="copyLink()">Share link</button>
        <button class="small secondary" onclick="toggleNetLog()">Network log</button>
      </div>
      <div class="net-log hidden" id="net-log" style="width:100%;"></div>
    </div>
  </section>

  <!-- ============================================================== -->
  <!-- ENROLLMENT / IDENTITY                                          -->
  <!-- ============================================================== -->
  <section id="sec-enroll">
    <div class="id-banner" id="id-banner">
      <div>
        <div class="meta">Identity</div>
        <div class="status not-enrolled" id="id-text">Not yet verified</div>
      </div>
      <button id="id-btn" onclick="toggleEnroll()">Verify Identity</button>
    </div>

    <div class="card hidden" id="enroll-card">
      <h2>Biometric Verification</h2>
      <p class="desc">
        Select at least 2 factors. In production, your device would scan real biometrics.
        The raw data never leaves your device — only a cryptographic key is shared with
        your peers for verification.
      </p>

      <div class="prog"><div class="bar" id="prog-bar" style="width:0%"></div></div>

      <div class="factors" id="factors">
        <div class="factor" data-f="fingerprint" onclick="pickFactor(this)">
          <div class="ic">&#9757;</div>
          <div class="nm">Fingerprint</div>
          <div class="check">&#10003; selected</div>
        </div>
        <div class="factor" data-f="face" onclick="pickFactor(this)">
          <div class="ic">&#128100;</div>
          <div class="nm">Face</div>
          <div class="check">&#10003; selected</div>
        </div>
        <div class="factor" data-f="iris" onclick="pickFactor(this)">
          <div class="ic">&#128065;</div>
          <div class="nm">Iris Scan</div>
          <div class="check">&#10003; selected</div>
        </div>
        <div class="factor" data-f="voice" onclick="pickFactor(this)">
          <div class="ic">&#127908;</div>
          <div class="nm">Voice</div>
          <div class="check">&#10003; selected</div>
        </div>
      </div>

      <button class="green full" id="enroll-btn" onclick="doEnroll()" disabled>
        Select at least 2 factors
      </button>
    </div>
  </section>

  <!-- ============================================================== -->
  <!-- CREATE TOPIC                                                   -->
  <!-- ============================================================== -->
  <section id="sec-create-topic">
    <div class="card">
      <h2>Create a Topic</h2>
      <p class="desc">Add a question or issue for the group to participate in.</p>
      <button class="secondary" onclick="document.getElementById('create-topic-form').classList.toggle('hidden')">
        + New Topic
      </button>
      <div id="create-topic-form" class="create-topic-form hidden">
        <div class="field">
          <label for="new-topic-title">Title</label>
          <input type="text" id="new-topic-title" placeholder="e.g. Should we adopt universal basic income?">
        </div>
        <div class="field">
          <label for="new-topic-desc">Description</label>
          <textarea id="new-topic-desc" rows="2" placeholder="Explain the issue..."></textarea>
        </div>
        <div class="field">
          <label for="new-topic-options">Vote options (comma-separated, leave blank for opinion-only)</label>
          <input type="text" id="new-topic-options" placeholder="e.g. Yes, No, Needs more research">
        </div>
        <button class="green" onclick="createTopic()">Create Topic</button>
      </div>
    </div>
  </section>

  <!-- ============================================================== -->
  <!-- TOPICS                                                         -->
  <!-- ============================================================== -->
  <section id="sec-topics">
    <h2 style="margin-bottom:0.75rem; font-size:1.15rem;">Open Topics</h2>
    <div id="topic-list"></div>
  </section>

  <!-- ============================================================== -->
  <!-- PARTICIPATE                                                    -->
  <!-- ============================================================== -->
  <section id="sec-participate" class="hidden">
    <div class="card">
      <h2 id="part-title"></h2>
      <p class="desc" id="part-desc"></p>

      <div class="tabs" id="part-tabs"></div>

      <div id="form-opinion" class="hidden">
        <div class="field">
          <label for="txt-opinion">Share your perspective</label>
          <textarea id="txt-opinion" rows="4" placeholder="What do you think about this issue?"></textarea>
        </div>
        <button class="green" onclick="send('opinion')">Submit Opinion</button>
      </div>

      <div id="form-idea" class="hidden">
        <div class="field">
          <label for="txt-idea">Propose a solution or approach</label>
          <textarea id="txt-idea" rows="4" placeholder="Describe your idea..."></textarea>
        </div>
        <button class="green" onclick="send('idea')">Submit Idea</button>
      </div>

      <div id="form-vote" class="hidden">
        <div class="field">
          <label for="sel-vote">Cast your vote</label>
          <select id="sel-vote"></select>
        </div>
        <button class="green" onclick="send('vote')">Cast Vote</button>
      </div>
    </div>

    <div class="card">
      <h2>What others have said</h2>
      <div id="sub-list">
        <p style="color:var(--text2); font-size:0.85rem;">
          No submissions yet. Be the first to participate.
        </p>
      </div>
    </div>
  </section>

  <!-- ============================================================== -->
  <!-- COLLECTIVE INTELLIGENCE PANEL                                  -->
  <!-- ============================================================== -->
  <section id="sec-analysis">
    <div class="analysis-panel">
      <h2>Collective Intelligence</h2>
      <p class="subtitle">
        Real-time AI analysis running locally in every browser. No server.
        All processing is transparent and auditable.
      </p>

      <div id="analysis-content">
        <div class="analysis-empty">
          Waiting for submissions. Analysis begins automatically as opinions arrive.
        </div>
      </div>
    </div>
  </section>

  <!-- ============================================================== -->
  <!-- PRIVACY                                                        -->
  <!-- ============================================================== -->
  <div class="privacy" id="sec-privacy">
    <strong>How your data is protected:</strong>
    Biometric scans are processed on your device only. A cryptographic key
    is generated locally and the public half is shared with peers so they can
    verify your submissions. All data is replicated across every connected browser
    in a single global mesh — there is no central server to hack, shut down, or
    censor. If any peer goes offline, the remaining network still holds the
    complete record. One key per person means one vote per person.
    <br><br>
    <strong>Durable storage:</strong>
    All replicated data (enrollments, topics, submissions) is persisted to
    IndexedDB on your device. When you reopen the page — even after closing
    the browser — your node rehydrates from local storage and shares what
    it knows with peers. Data propagation uses G-Set CRDTs (grow-only sets)
    with set-union merge, so there are no conflicts.
    <br><br>
    <strong>Local AI processing:</strong>
    Sentiment analysis, opinion clustering, and bias detection all run
    locally in your browser. Every peer independently computes the same
    results from the same replicated data. No external AI service is
    contacted.
  </div>
</div>

<footer>
  OpenDemocracy &mdash; one global mesh, no server, no censorship, no single point of failure
  &middot; <a href="https://github.com/AshmanRoonz/OpenDemocracy" target="_blank">GitHub</a>
</footer>

<!-- PeerJS for WebRTC signaling -->
<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

<script>
/* ==================================================================
   OpenDemocracy — Peer-to-Peer Edition with Persistent Storage
   ==================================================================
   Architecture:
   - Every browser is both client AND server
   - WebRTC data channels (via PeerJS) connect peers directly
   - Full mesh: every peer connects to every other peer
   - State (enrollments, topics, submissions) replicated via gossip
   - Each peer independently verifies all cryptographic signatures
   - No central server — host on GitHub Pages, open from file://, anywhere
   -
   - PERSISTENCE (Phase 3):
   -   Data model: G-Set CRDTs (grow-only sets). Enrollments, topics,
   -   and submissions are append-only, keyed by unique IDs. The merge
   -   operation is set union — commutative, associative, idempotent.
   -   No conflicts possible.
   -
   -   Storage: IndexedDB for durable local persistence. Every mutation
   -   is written through to IndexedDB so state survives tab close,
   -   browser restart, and offline periods.
   -
   -   Sync: On peer connect, nodes exchange a compact state digest
   -   (counts per collection). If digests differ, only the missing
   -   entries are transmitted (anti-entropy). Real-time mutations
   -   still propagate via gossip broadcast.
   -
   -   Eviction: The seen-set (message dedup) is capped at 10,000
   -   entries with LRU eviction. Topics can be archived after a
   -   configurable age. Storage usage is monitored and displayed.
   -
   -   Why not IPFS/libp2p? Too heavy for Phase 3 — adds ~400KB of
   -   JS dependencies, requires DHT bootstrap nodes, and the data
   -   volumes here (text submissions) don't warrant content-addressed
   -   blob storage yet. IndexedDB + gossip gives us durable, offline-
   -   capable persistence with zero extra dependencies. IPFS is the
   -   right move for Phase 4 (planetary scale) when we need cross-
   -   room persistence and archival pinning.
   ================================================================== */

/* ==================================================================
   INDEXEDDB PERSISTENCE LAYER
   ================================================================== */

const DB_NAME = "opendemocracy_p2p";
const DB_VERSION = 1;
const STORES = ["enrollments", "topics", "submissions", "seen", "meta"];

const store = {
  db: null,

  open() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        for (const name of STORES) {
          if (!db.objectStoreNames.contains(name)) {
            db.createObjectStore(name);
          }
        }
      };
      req.onsuccess = (e) => {
        store.db = e.target.result;
        resolve(store.db);
      };
      req.onerror = (e) => {
        console.warn("IndexedDB open failed, running in-memory only:", e.target.error);
        resolve(null);
      };
    });
  },

  // Generic put: store a value by key in the named object store
  put(storeName, key, value) {
    if (!store.db) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const tx = store.db.transaction(storeName, "readwrite");
      tx.objectStore(storeName).put(value, key);
      tx.oncomplete = () => resolve();
      tx.onerror = (e) => { console.warn("IDB put error:", e.target.error); resolve(); };
    });
  },

  // Generic get: retrieve a value by key
  get(storeName, key) {
    if (!store.db) return Promise.resolve(undefined);
    return new Promise((resolve, reject) => {
      const tx = store.db.transaction(storeName, "readonly");
      const req = tx.objectStore(storeName).get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = (e) => { console.warn("IDB get error:", e.target.error); resolve(undefined); };
    });
  },

  // Get all entries from a store as [key, value] pairs
  getAll(storeName) {
    if (!store.db) return Promise.resolve([]);
    return new Promise((resolve, reject) => {
      const tx = store.db.transaction(storeName, "readonly");
      const os = tx.objectStore(storeName);
      const keys = [];
      const values = [];
      const kReq = os.getAllKeys();
      const vReq = os.getAll();
      tx.oncomplete = () => {
        const pairs = [];
        for (let i = 0; i < keys.length; i++) pairs.push([keys[i], values[i]]);
        resolve(pairs);
      };
      kReq.onsuccess = () => { keys.push(...kReq.result); };
      vReq.onsuccess = () => { values.push(...vReq.result); };
      tx.onerror = (e) => { console.warn("IDB getAll error:", e.target.error); resolve([]); };
    });
  },

  // Delete a key from a store
  del(storeName, key) {
    if (!store.db) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const tx = store.db.transaction(storeName, "readwrite");
      tx.objectStore(storeName).delete(key);
      tx.oncomplete = () => resolve();
      tx.onerror = (e) => { console.warn("IDB del error:", e.target.error); resolve(); };
    });
  },

  // Count entries in a store
  count(storeName) {
    if (!store.db) return Promise.resolve(0);
    return new Promise((resolve, reject) => {
      const tx = store.db.transaction(storeName, "readonly");
      const req = tx.objectStore(storeName).count();
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => resolve(0);
    });
  },

  // Bulk put for initial sync (batch write in a single transaction)
  putBatch(storeName, entries) {
    if (!store.db || !entries.length) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const tx = store.db.transaction(storeName, "readwrite");
      const os = tx.objectStore(storeName);
      for (const [key, value] of entries) {
        os.put(value, key);
      }
      tx.oncomplete = () => resolve();
      tx.onerror = (e) => { console.warn("IDB batch error:", e.target.error); resolve(); };
    });
  },

  // Estimate storage usage (bytes) — uses Storage API where available
  async estimateUsage() {
    if (navigator.storage && navigator.storage.estimate) {
      const est = await navigator.storage.estimate();
      return { used: est.usage || 0, quota: est.quota || 0 };
    }
    // Fallback: count entries
    const e = await store.count("enrollments");
    const t = await store.count("topics");
    const s = await store.count("submissions");
    return { used: (e + t + s) * 500, quota: 0, entries: e + t + s }; // rough estimate
  },
};

/* ==================================================================
   SEEN-SET WITH LRU EVICTION
   ================================================================== */

const SEEN_MAX = 10000;

const seenSet = {
  // Ordered map: msgId -> timestamp. Oldest entries evicted first.
  _map: new Map(),

  has(msgId) {
    return seenSet._map.has(msgId);
  },

  add(msgId) {
    if (seenSet._map.has(msgId)) return;
    seenSet._map.set(msgId, Date.now());
    // Evict oldest if over capacity
    if (seenSet._map.size > SEEN_MAX) {
      const oldest = seenSet._map.keys().next().value;
      seenSet._map.delete(oldest);
      store.del("seen", oldest);
    }
    // Persist (fire-and-forget)
    store.put("seen", msgId, Date.now());
  },

  get size() {
    return seenSet._map.size;
  },

  // Load from IndexedDB on boot
  async load() {
    const pairs = await store.getAll("seen");
    // Sort by timestamp ascending so oldest are first in map
    pairs.sort((a, b) => a[1] - b[1]);
    for (const [key, ts] of pairs) {
      seenSet._map.set(key, ts);
    }
    // Trim if DB had more than the cap
    while (seenSet._map.size > SEEN_MAX) {
      const oldest = seenSet._map.keys().next().value;
      seenSet._map.delete(oldest);
      store.del("seen", oldest);
    }
  },
};

/* ==================================================================
   P2P STATE
   ================================================================== */

const state = {
  roomId: null,
  isHost: false,
  myPeerId: null,
  peer: null,              // PeerJS instance
  connections: new Map(),  // peerId -> DataConnection
  peerList: [],            // known peer IDs

  // Replicated data (same on every peer) — G-Set CRDTs
  enrollments: new Map(),  // anonymous_id -> { public_key, factors, enrolled_at }
  topics: new Map(),       // topic_id -> { id, title, description, ... }
  submissions: new Map(),  // submission_id -> { id, topic_id, anonymous_id, type, content, signature, ... }

  // Persistence flag
  dbReady: false,
};

/* ---- Local identity (only on this browser) ---- */
let me = JSON.parse(localStorage.getItem("od_p2p_me") || "null");
let selectedFactors = [];
let currentTopic = null;
let currentTab = "opinion";

/* ==================================================================
   STATE HELPERS (write-through to IndexedDB)
   ================================================================== */

async function addEnrollment(id, data) {
  if (state.enrollments.has(id)) return false;
  state.enrollments.set(id, data);
  await store.put("enrollments", id, data);
  return true;
}

async function addTopic(id, data) {
  if (state.topics.has(id)) return false;
  state.topics.set(id, data);
  await store.put("topics", id, data);
  return true;
}

async function addSubmission(id, data) {
  if (state.submissions.has(id)) return false;
  state.submissions.set(id, data);
  await store.put("submissions", id, data);
  return true;
}

// Rehydrate in-memory state from IndexedDB
async function rehydrate() {
  const [enrollments, topics, submissions] = await Promise.all([
    store.getAll("enrollments"),
    store.getAll("topics"),
    store.getAll("submissions"),
    seenSet.load(),
  ]);

  let loaded = 0;
  for (const [id, data] of enrollments) {
    state.enrollments.set(id, data);
    loaded++;
  }
  for (const [id, data] of topics) {
    state.topics.set(id, data);
    loaded++;
  }
  for (const [id, data] of submissions) {
    state.submissions.set(id, data);
    loaded++;
  }

  state.dbReady = true;
  return loaded;
}

// Build a compact digest of our state for anti-entropy sync
function stateDigest() {
  return {
    enrollmentIds: [...state.enrollments.keys()],
    topicIds: [...state.topics.keys()],
    submissionIds: [...state.submissions.keys()],
  };
}

/* ==================================================================
   CRYPTO (all in-browser via Web Crypto API)
   ================================================================== */

async function generateKeypair() {
  // Generate HMAC key for signing (prototype — production would use Ed25519)
  const rawKey = new Uint8Array(32);
  crypto.getRandomValues(rawKey);
  const privateKey = bytesToHex(rawKey);
  const publicKey = bytesToHex(new Uint8Array(
    await crypto.subtle.digest("SHA-256", rawKey)
  ));
  return { privateKey, publicKey };
}

async function signMessage(publicKey, message) {
  // HMAC-SHA256 sign using public key (matches the server prototype's scheme)
  const enc = new TextEncoder();
  const key = await crypto.subtle.importKey(
    "raw", enc.encode(publicKey),
    { name: "HMAC", hash: "SHA-256" }, false, ["sign"]
  );
  const sig = await crypto.subtle.sign("HMAC", key, enc.encode(message));
  return bytesToHex(new Uint8Array(sig));
}

async function verifySignature(publicKey, message, signature) {
  const expected = await signMessage(publicKey, message);
  return expected === signature;
}

function generateId(len = 12) {
  const arr = new Uint8Array(len);
  crypto.getRandomValues(arr);
  return bytesToHex(arr).slice(0, len);
}

function bytesToHex(bytes) {
  return [...bytes].map(b => b.toString(16).padStart(2, "0")).join("");
}

/* ==================================================================
   GLOBAL MESH — single network, auto-join
   ==================================================================
   There's one mesh for all of OpenDemocracy. No rooms, no codes.
   Under the hood, one PeerJS ID ("od-global-hub") acts as the
   initial rendezvous point. If that ID is already taken (someone
   else is the hub), we join as a regular peer and connect to them.
   Once connected, all peers share their known peer lists and the
   mesh self-heals — the hub is just the entry point, not a single
   point of failure.
   ================================================================== */

const GLOBAL_HUB_ID = "od-global-hub";

function joinGlobalMesh() {
  state.roomId = "global";
  // Try to become the hub first. If the ID is taken, join as a peer.
  state.isHost = true;
  initPeer(GLOBAL_HUB_ID);
}

function initPeer(peerId) {
  const opts = { debug: 0 };
  state.peer = peerId ? new Peer(peerId, opts) : new Peer(opts);

  state.peer.on("open", (id) => {
    state.myPeerId = id;
    netLog("Connected as: " + id, "ok");
    document.getElementById("room-id-display").textContent = "Global Mesh";
    document.getElementById("room-meta").textContent =
      (id === GLOBAL_HUB_ID)
        ? "You are the hub node (entry point for new peers)"
        : "Connected — " + id.slice(0, 8) + "...";

    showRoomUI();

    // If we're not the hub, connect to the hub to bootstrap
    if (id !== GLOBAL_HUB_ID) {
      connectToPeer(GLOBAL_HUB_ID);
    }
  });

  state.peer.on("connection", (conn) => {
    setupConnection(conn);
  });

  state.peer.on("error", (err) => {
    if (err.type === "unavailable-id") {
      // Hub ID already taken — good, join as a regular peer
      netLog("Hub exists, joining as peer...", "ok");
      state.isHost = false;
      initPeer(null); // random ID, then connect to hub
    } else if (err.type === "peer-unavailable") {
      netLog("Hub offline. You are the only node — others will connect to you.", "warn");
      document.getElementById("room-meta").textContent = "Standalone — waiting for peers";
    } else {
      netLog("Error: " + err.type + " — " + err.message, "err");
    }
  });
}

function connectToPeer(peerId) {
  if (peerId === state.myPeerId) return;
  if (state.connections.has(peerId)) return;

  netLog("Connecting to " + peerId + "...");
  const conn = state.peer.connect(peerId, { reliable: true });
  setupConnection(conn);
}

function setupConnection(conn) {
  conn.on("open", () => {
    state.connections.set(conn.peer, conn);
    netLog("Peer connected: " + conn.peer, "ok");
    updateStats();

    // Anti-entropy: send our digest first. The peer compares and requests
    // only the entries it's missing. Falls back to full sync if the peer
    // doesn't support digests (backwards compatible).
    conn.send({
      type: "digest",
      msgId: generateId(),
      digest: stateDigest(),
      peerList: [...state.connections.keys(), state.myPeerId],
    });
  });

  conn.on("data", (data) => handleMessage(data, conn.peer));

  conn.on("close", () => {
    state.connections.delete(conn.peer);
    netLog("Peer disconnected: " + conn.peer, "warn");
    updateStats();
  });

  conn.on("error", (err) => {
    netLog("Connection error with " + conn.peer + ": " + err, "err");
  });
}

/* ==================================================================
   GOSSIP PROTOCOL (with anti-entropy sync)
   ================================================================== */

function broadcast(msg) {
  // Tag every message with a unique ID for dedup
  if (!msg.msgId) msg.msgId = generateId(16);
  seenSet.add(msg.msgId);

  for (const [, conn] of state.connections) {
    try { conn.send(msg); } catch (_) { /* peer may have disconnected */ }
  }
}

async function handleMessage(msg, fromPeer) {
  // Dedup: ignore messages we've already seen
  if (msg.msgId && seenSet.has(msg.msgId)) return;
  if (msg.msgId) seenSet.add(msg.msgId);

  switch (msg.type) {
    case "digest":
      await handleDigest(msg, fromPeer);
      break;
    case "digest-request":
      await handleDigestRequest(msg, fromPeer);
      break;
    case "sync":
      await handleSync(msg, fromPeer);
      break;
    case "enroll":
      await handleEnrollMsg(msg);
      break;
    case "topic":
      await handleTopicMsg(msg);
      break;
    case "submit":
      await handleSubmitMsg(msg);
      break;
  }
}

// Anti-entropy: receive a peer's digest and compute what they need
async function handleDigest(msg, fromPeer) {
  netLog("Digest from " + fromPeer + " — comparing state", "ok");
  const remote = msg.digest;
  const remoteEnrollIds = new Set(remote.enrollmentIds);
  const remoteTopicIds = new Set(remote.topicIds);
  const remoteSubIds = new Set(remote.submissionIds);

  // What we have that they don't
  const missingEnrollments = [];
  for (const [id, data] of state.enrollments) {
    if (!remoteEnrollIds.has(id)) missingEnrollments.push([id, data]);
  }
  const missingTopics = [];
  for (const [id, data] of state.topics) {
    if (!remoteTopicIds.has(id)) missingTopics.push([id, data]);
  }
  const missingSubmissions = [];
  for (const [id, data] of state.submissions) {
    if (!remoteSubIds.has(id)) missingSubmissions.push([id, data]);
  }

  const conn = state.connections.get(fromPeer);
  if (!conn) return;

  // Send them what they're missing
  if (missingEnrollments.length || missingTopics.length || missingSubmissions.length) {
    netLog("Sending " + (missingEnrollments.length + missingTopics.length + missingSubmissions.length) + " missing entries to " + fromPeer, "ok");
    conn.send({
      type: "sync",
      msgId: generateId(),
      enrollments: missingEnrollments,
      topics: missingTopics,
      submissions: missingSubmissions,
      peerList: [...state.connections.keys(), state.myPeerId],
    });
  }

  // What they have that we don't — request it
  const weNeedEnrollIds = remote.enrollmentIds.filter(id => !state.enrollments.has(id));
  const weNeedTopicIds = remote.topicIds.filter(id => !state.topics.has(id));
  const weNeedSubIds = remote.submissionIds.filter(id => !state.submissions.has(id));

  if (weNeedEnrollIds.length || weNeedTopicIds.length || weNeedSubIds.length) {
    netLog("Requesting " + (weNeedEnrollIds.length + weNeedTopicIds.length + weNeedSubIds.length) + " missing entries from " + fromPeer, "ok");
    conn.send({
      type: "digest-request",
      msgId: generateId(),
      enrollmentIds: weNeedEnrollIds,
      topicIds: weNeedTopicIds,
      submissionIds: weNeedSubIds,
    });
  }

  // Connect to peers we don't know yet
  for (const peerId of (msg.peerList || [])) {
    if (peerId !== state.myPeerId && !state.connections.has(peerId)) {
      connectToPeer(peerId);
    }
  }
}

// Handle a request for specific entries by ID
async function handleDigestRequest(msg, fromPeer) {
  const conn = state.connections.get(fromPeer);
  if (!conn) return;

  const enrollments = (msg.enrollmentIds || [])
    .filter(id => state.enrollments.has(id))
    .map(id => [id, state.enrollments.get(id)]);
  const topics = (msg.topicIds || [])
    .filter(id => state.topics.has(id))
    .map(id => [id, state.topics.get(id)]);
  const submissions = (msg.submissionIds || [])
    .filter(id => state.submissions.has(id))
    .map(id => [id, state.submissions.get(id)]);

  if (enrollments.length || topics.length || submissions.length) {
    conn.send({
      type: "sync",
      msgId: generateId(),
      enrollments,
      topics,
      submissions,
      peerList: [...state.connections.keys(), state.myPeerId],
    });
  }
}

async function handleSync(msg, fromPeer) {
  netLog("State sync from " + fromPeer, "ok");
  let added = 0;

  // Merge enrollments (write-through to IndexedDB)
  const newEnrollments = [];
  for (const [id, data] of msg.enrollments) {
    if (!state.enrollments.has(id)) {
      state.enrollments.set(id, data);
      newEnrollments.push([id, data]);
      added++;
    }
  }
  if (newEnrollments.length) await store.putBatch("enrollments", newEnrollments);

  // Merge topics
  const newTopics = [];
  for (const [id, data] of msg.topics) {
    if (!state.topics.has(id)) {
      state.topics.set(id, data);
      newTopics.push([id, data]);
      added++;
    }
  }
  if (newTopics.length) await store.putBatch("topics", newTopics);

  // Merge submissions (verify each one)
  const newSubmissions = [];
  for (const [id, data] of msg.submissions) {
    if (!state.submissions.has(id)) {
      const enrollment = state.enrollments.get(data.anonymous_id);
      if (enrollment) {
        const valid = await verifySignature(
          enrollment.public_key, data.nonce, data.signature
        );
        if (valid) {
          state.submissions.set(id, data);
          newSubmissions.push([id, data]);
          added++;
        } else {
          netLog("Rejected invalid submission " + id, "warn");
        }
      }
    }
  }
  if (newSubmissions.length) await store.putBatch("submissions", newSubmissions);

  if (added > 0) {
    netLog("Merged " + added + " new entries from " + fromPeer, "ok");
  }

  // Connect to peers we don't know yet
  for (const peerId of (msg.peerList || [])) {
    if (peerId !== state.myPeerId && !state.connections.has(peerId)) {
      connectToPeer(peerId);
    }
  }

  refreshAll();
  updateStorageStats();
}

async function handleEnrollMsg(msg) {
  const added = await addEnrollment(msg.anonymous_id, {
    public_key: msg.public_key,
    factors: msg.factors,
    enrolled_at: msg.enrolled_at,
  });
  if (!added) return;
  // Re-gossip to peers who may not have seen it
  broadcast(msg);
  refreshAll();
  updateStorageStats();
}

async function handleTopicMsg(msg) {
  const added = await addTopic(msg.topic.id, msg.topic);
  if (!added) return;
  broadcast(msg);
  refreshAll();
  updateStorageStats();
}

async function handleSubmitMsg(msg) {
  if (state.submissions.has(msg.submission.id)) return;

  // Verify the signature before accepting
  const enrollment = state.enrollments.get(msg.submission.anonymous_id);
  if (!enrollment) {
    netLog("Rejected submission from unknown identity", "warn");
    return;
  }

  const valid = await verifySignature(
    enrollment.public_key,
    msg.submission.nonce,
    msg.submission.signature
  );
  if (!valid) {
    netLog("Rejected submission with invalid signature", "warn");
    return;
  }

  // Check one-person-one-vote per topic+type
  for (const [, sub] of state.submissions) {
    if (sub.topic_id === msg.submission.topic_id &&
        sub.anonymous_id === msg.submission.anonymous_id &&
        sub.submission_type === msg.submission.submission_type) {
      netLog("Rejected duplicate submission", "warn");
      return;
    }
  }

  await addSubmission(msg.submission.id, msg.submission);
  broadcast(msg);
  refreshAll();
  updateStorageStats();
}

/* ==================================================================
   LOCAL ACTIONS
   ================================================================== */

async function doEnroll() {
  const btn = document.getElementById("enroll-btn");
  btn.disabled = true;
  btn.textContent = "Scanning biometrics...";
  await pause(1200);
  btn.textContent = "Generating cryptographic key...";
  await pause(600);

  const { privateKey, publicKey } = await generateKeypair();
  const anonymousId = generateId(16);
  const factorNames = [...selectedFactors];

  const enrollment = {
    public_key: publicKey,
    factors: factorNames,
    enrolled_at: new Date().toISOString(),
  };
  await addEnrollment(anonymousId, enrollment);

  // Save locally (private key NEVER leaves this browser)
  me = {
    anonymous_id: anonymousId,
    public_key: publicKey,
    private_key: privateKey,
    factors_enrolled: factorNames,
  };
  localStorage.setItem("od_p2p_me", JSON.stringify(me));

  // Broadcast enrollment to all peers
  broadcast({
    type: "enroll",
    anonymous_id: anonymousId,
    public_key: publicKey,
    factors: factorNames,
    enrolled_at: enrollment.enrolled_at,
  });

  refreshIdentity();
  updateStats();
  updateStorageStats();
  flash("Identity verified. Your private key is stored only in this browser.", "ok");
}

async function createTopic() {
  const title = document.getElementById("new-topic-title").value.trim();
  const desc = document.getElementById("new-topic-desc").value.trim();
  const optStr = document.getElementById("new-topic-options").value.trim();
  if (!title) { flash("Enter a topic title.", "err"); return; }

  const voteOptions = optStr ? optStr.split(",").map(s => s.trim()).filter(Boolean) : [];
  const topic = {
    id: generateId(12),
    title,
    description: desc,
    allow_opinions: true,
    allow_ideas: true,
    allow_votes: voteOptions.length > 0,
    vote_options: voteOptions,
    created_at: new Date().toISOString(),
  };

  await addTopic(topic.id, topic);
  broadcast({ type: "topic", topic });

  // Clear form
  document.getElementById("new-topic-title").value = "";
  document.getElementById("new-topic-desc").value = "";
  document.getElementById("new-topic-options").value = "";
  document.getElementById("create-topic-form").classList.add("hidden");

  refreshAll();
  updateStorageStats();
  flash("Topic created and shared with all peers.", "ok");
}

async function send(type) {
  if (!me) { flash("You must verify your identity first.", "err"); return; }
  if (!currentTopic) return;

  let content = "";
  if (type === "opinion") content = document.getElementById("txt-opinion").value.trim();
  else if (type === "idea") content = document.getElementById("txt-idea").value.trim();
  else if (type === "vote") content = document.getElementById("sel-vote").value;
  if (!content) { flash("Please enter your " + type + " first.", "err"); return; }

  // Check if already submitted this type for this topic
  for (const [, sub] of state.submissions) {
    if (sub.topic_id === currentTopic.id &&
        sub.anonymous_id === me.anonymous_id &&
        sub.submission_type === type) {
      flash("You already submitted a " + type + " for this topic.", "err");
      return;
    }
  }

  // Generate a nonce and sign it
  const nonce = generateId(32);
  const signature = await signMessage(me.public_key, nonce);

  const submission = {
    id: generateId(12),
    topic_id: currentTopic.id,
    anonymous_id: me.anonymous_id,
    submission_type: type,
    content,
    nonce,
    signature,
    submitted_at: new Date().toISOString(),
  };

  await addSubmission(submission.id, submission);
  broadcast({ type: "submit", submission });

  if (type === "opinion") document.getElementById("txt-opinion").value = "";
  if (type === "idea") document.getElementById("txt-idea").value = "";
  refreshAll();
  updateStorageStats();
  flash(type.charAt(0).toUpperCase() + type.slice(1) + " submitted and broadcast to all peers.", "ok");
}

/* ==================================================================
   UI
   ================================================================== */

async function showRoomUI() {
  // If already enrolled from a previous session, restore and broadcast identity
  if (me) {
    if (!state.enrollments.has(me.anonymous_id)) {
      const enrollment = {
        public_key: me.public_key,
        factors: me.factors_enrolled,
        enrolled_at: new Date().toISOString(),
      };
      await addEnrollment(me.anonymous_id, enrollment);
      broadcast({
        type: "enroll",
        anonymous_id: me.anonymous_id,
        public_key: me.public_key,
        factors: me.factors_enrolled,
        enrolled_at: enrollment.enrolled_at,
      });
    }
  }

  refreshIdentity();
  refreshAll();
  updateStorageStats();
}

function refreshIdentity() {
  const txt = document.getElementById("id-text");
  const btn = document.getElementById("id-btn");
  if (me) {
    txt.textContent = "Verified (" + me.factors_enrolled.join(", ") + ")";
    txt.className = "status enrolled";
    btn.textContent = "Verified";
    btn.disabled = true;
    btn.className = "secondary";
    document.getElementById("enroll-card").classList.add("hidden");
  } else {
    txt.textContent = "Not yet verified";
    txt.className = "status not-enrolled";
    btn.textContent = "Verify Identity";
    btn.disabled = false;
  }
}

function toggleEnroll() {
  document.getElementById("enroll-card").classList.toggle("hidden");
}

function pickFactor(el) {
  const f = el.dataset.f;
  el.classList.toggle("on");
  selectedFactors = [...document.querySelectorAll(".factor.on")].map(e => e.dataset.f);
  const pct = Math.min((selectedFactors.length / 2) * 100, 100);
  document.getElementById("prog-bar").style.width = pct + "%";
  const btn = document.getElementById("enroll-btn");
  btn.disabled = selectedFactors.length < 2;
  btn.textContent = selectedFactors.length < 2
    ? "Select at least 2 factors"
    : "Verify with " + selectedFactors.join(" + ");
}

function refreshAll() {
  renderTopics();
  if (currentTopic) {
    renderSubmissions(currentTopic.id);
    runAnalysis(currentTopic.id);
  }
  updateStats();
}

function renderTopics() {
  const el = document.getElementById("topic-list");
  const topics = [...state.topics.values()];
  if (!topics.length) {
    el.innerHTML = '<p style="color:var(--text2)">No topics yet. Create one above.</p>';
    return;
  }
  el.innerHTML = topics.map(t =>
    '<div class="card topic' + (currentTopic && currentTopic.id === t.id ? ' on' : '') +
    '" onclick="openTopic(\'' + t.id + '\')">' +
    '<h3>' + esc(t.title) + '</h3>' +
    '<p class="desc">' + esc(t.description) + '</p>' +
    '</div>'
  ).join("");
}

function openTopic(id) {
  const t = state.topics.get(id);
  if (!t) return;
  currentTopic = t;

  document.querySelectorAll(".topic").forEach(el => {
    el.classList.toggle("on", el.querySelector("h3").textContent === t.title);
  });

  document.getElementById("sec-participate").classList.remove("hidden");
  document.getElementById("part-title").textContent = t.title;
  document.getElementById("part-desc").textContent = t.description;

  const allowed = [];
  if (t.allow_opinions) allowed.push("opinion");
  if (t.allow_ideas) allowed.push("idea");
  if (t.allow_votes) allowed.push("vote");
  document.getElementById("part-tabs").innerHTML = allowed.map(x =>
    '<div class="tab" onclick="setTab(\'' + x + '\')">' +
    x.charAt(0).toUpperCase() + x.slice(1) +
    '</div>'
  ).join("");
  if (allowed.length) setTab(allowed[0]);

  if (t.vote_options && t.vote_options.length) {
    document.getElementById("sel-vote").innerHTML =
      t.vote_options.map(o => '<option value="' + esc(o) + '">' + esc(o) + '</option>').join("");
  }

  renderSubmissions(id);
}

function setTab(t) {
  currentTab = t;
  document.querySelectorAll(".tab").forEach(el =>
    el.classList.toggle("on", el.textContent.toLowerCase() === t)
  );
  document.getElementById("form-opinion").classList.toggle("hidden", t !== "opinion");
  document.getElementById("form-idea").classList.toggle("hidden", t !== "idea");
  document.getElementById("form-vote").classList.toggle("hidden", t !== "vote");
}

function renderSubmissions(topicId) {
  const subs = [...state.submissions.values()].filter(s => s.topic_id === topicId);
  const el = document.getElementById("sub-list");
  if (!subs.length) {
    el.innerHTML = '<p style="color:var(--text2); font-size:0.85rem;">No submissions yet. Be the first.</p>';
    return;
  }
  el.innerHTML = subs.map(s =>
    '<div class="sub-item">' +
    '<span class="badge badge-' + s.submission_type + '">' + s.submission_type + '</span>' +
    esc(s.content) +
    '</div>'
  ).join("");
}

function updateStats() {
  document.getElementById("st-peers").textContent = state.connections.size;
  document.getElementById("st-enrolled").textContent = state.enrollments.size;
  document.getElementById("st-subs").textContent = state.submissions.size;

  const dot = document.getElementById("net-dot");
  dot.className = state.connections.size > 0 ? "peer-dot" : "peer-dot off";
}

async function updateStorageStats() {
  const usage = await store.estimateUsage();
  const el = document.getElementById("st-storage");
  if (usage.quota > 0) {
    const pct = ((usage.used / usage.quota) * 100).toFixed(1);
    const usedMB = (usage.used / 1024 / 1024).toFixed(1);
    el.innerHTML = 'Storage: <strong title="' + usedMB + ' MB used">' + pct + '%</strong>';
  } else if (usage.entries !== undefined) {
    el.innerHTML = 'Storage: <strong>' + usage.entries + ' entries</strong>';
  } else {
    el.innerHTML = 'Storage: <strong>active</strong>';
  }
}

function copyLink() {
  const url = window.location.origin + window.location.pathname;
  navigator.clipboard.writeText(url).then(() => {
    flash("Link copied. Anyone who opens it joins the same global mesh.", "ok");
  }).catch(() => {
    flash("Link: " + url, "ok");
  });
}

/* ---- Network log ---- */
function toggleNetLog() {
  document.getElementById("net-log").classList.toggle("hidden");
}

function netLog(msg, cls) {
  const el = document.getElementById("net-log");
  if (!el) return;
  const div = document.createElement("div");
  div.textContent = new Date().toLocaleTimeString() + " " + msg;
  if (cls) div.className = cls;
  el.appendChild(div);
  el.scrollTop = el.scrollHeight;

  // Keep log from growing too large
  while (el.children.length > 100) el.removeChild(el.firstChild);
}

/* ---- Helpers ---- */
function flash(msg, type) {
  const el = document.getElementById("alert");
  el.textContent = msg;
  el.className = "alert " + type;
  el.scrollIntoView({ behavior: "smooth", block: "nearest" });
  setTimeout(() => { el.className = "alert"; }, 6000);
}

function esc(s) {
  const d = document.createElement("div");
  d.textContent = s;
  return d.innerHTML;
}

function pause(ms) { return new Promise(r => setTimeout(r, ms)); }

/* ==================================================================
   IN-BROWSER COLLECTIVE INTELLIGENCE ENGINE
   ==================================================================
   Ports the server-side Python processing pipeline to pure JS:
   - Multi-dimensional sentiment scoring (lexicon-based)
   - K-Means opinion clustering on sentiment feature vectors
   - Consensus/distribution analysis
   - Bias detection (duplicate content, temporal burst, sample size)
   - Vote tally with distribution breakdown

   Everything runs locally. No server calls. Every peer independently
   computes the same analysis from the same replicated data, which means
   every browser can independently verify the results.
   ================================================================== */

/* ---- Sentiment lexicons (mirrors processing/sentiment.py) ---- */
const LEX_SUPPORT = new Set([
  "support","favor","agree","benefit","good","positive","help",
  "advantage","pro","should","need","must","important","essential",
  "necessary","great","works","effective","promising","yes","definitely",
]);
const LEX_OPPOSE = new Set([
  "oppose","against","disagree","harmful","bad","negative","hurt",
  "disadvantage","con","shouldn't","terrible","fail","waste",
  "dangerous","risk","problem","worse","costly","ineffective","no",
]);
const LEX_URGENCY = new Set([
  "now","immediately","urgent","crisis","emergency","asap",
  "critical","desperate","overdue","finally","enough",
]);
const LEX_CERTAINTY = new Set([
  "definitely","certainly","clearly","obviously","proven",
  "evidence","fact","data","research","study","shows",
]);
const LEX_UNCERTAINTY = new Set([
  "maybe","perhaps","might","possibly","unclear","uncertain",
  "debatable","depends","unsure","questionable",
]);

function tokenize(text) {
  return text.toLowerCase().replace(/[^a-z0-9' ]/g, " ").split(/\s+/).filter(Boolean);
}

function wordRatio(words, lexicon) {
  if (!words.length) return 0;
  let hits = 0;
  for (const w of words) if (lexicon.has(w)) hits++;
  return hits / words.length;
}

function scoreSentiment(text) {
  const words = tokenize(text);
  const support = wordRatio(words, LEX_SUPPORT);
  const oppose = wordRatio(words, LEX_OPPOSE);
  const stance = support - oppose; // [-1, 1]
  const urgency = Math.min(wordRatio(words, LEX_URGENCY) * 5, 1.0);
  const certaintyPos = wordRatio(words, LEX_CERTAINTY);
  const certaintyNeg = wordRatio(words, LEX_UNCERTAINTY);
  const certainty = Math.tanh((certaintyPos - certaintyNeg) * 5);

  // Intensity proxy
  const excl = (text.match(/!/g) || []).length;
  const capsRatio = [...text].filter(c => c >= "A" && c <= "Z").length / Math.max(text.length, 1);
  const intensity = Math.min((excl * 0.15 + capsRatio) * 2, 1.0);

  return { stance, urgency, certainty, intensity };
}

/* ---- K-Means clustering (pure JS, no deps) ---- */

function kmeans(vectors, k, maxIter = 50) {
  const n = vectors.length;
  const dim = vectors[0].length;
  if (n <= k) {
    // Fewer points than clusters — each point is its own cluster
    return vectors.map((_, i) => i);
  }

  // Initialize centroids via k-means++ seeding
  const centroids = [vectors[Math.floor(Math.random() * n)].slice()];
  while (centroids.length < k) {
    const dists = vectors.map(v => {
      let minD = Infinity;
      for (const c of centroids) {
        let d = 0;
        for (let i = 0; i < dim; i++) d += (v[i] - c[i]) ** 2;
        minD = Math.min(minD, d);
      }
      return minD;
    });
    const total = dists.reduce((a, b) => a + b, 0);
    let r = Math.random() * total;
    for (let i = 0; i < n; i++) {
      r -= dists[i];
      if (r <= 0) { centroids.push(vectors[i].slice()); break; }
    }
    if (centroids.length === k - 1 + 1) break; // safety
  }
  // Pad if needed
  while (centroids.length < k) centroids.push(vectors[Math.floor(Math.random() * n)].slice());

  const labels = new Array(n).fill(0);

  for (let iter = 0; iter < maxIter; iter++) {
    let changed = false;

    // Assign
    for (let i = 0; i < n; i++) {
      let bestK = 0, bestD = Infinity;
      for (let c = 0; c < k; c++) {
        let d = 0;
        for (let j = 0; j < dim; j++) d += (vectors[i][j] - centroids[c][j]) ** 2;
        if (d < bestD) { bestD = d; bestK = c; }
      }
      if (labels[i] !== bestK) { labels[i] = bestK; changed = true; }
    }

    if (!changed) break;

    // Update centroids
    const sums = Array.from({ length: k }, () => new Array(dim).fill(0));
    const counts = new Array(k).fill(0);
    for (let i = 0; i < n; i++) {
      counts[labels[i]]++;
      for (let j = 0; j < dim; j++) sums[labels[i]][j] += vectors[i][j];
    }
    for (let c = 0; c < k; c++) {
      if (counts[c] === 0) continue;
      for (let j = 0; j < dim; j++) centroids[c][j] = sums[c][j] / counts[c];
    }
  }

  return labels;
}

/* ---- Bias detection (mirrors processing/bias.py) ---- */

function detectBias(submissions) {
  const warnings = [];
  if (submissions.length > 0 && submissions.length < 5) {
    warnings.push("Very small sample (" + submissions.length + " submissions). Results may not be representative.");
  }

  // Duplicate content
  const textCounts = {};
  for (const s of submissions) {
    const t = s.content.trim().toLowerCase();
    textCounts[t] = (textCounts[t] || 0) + 1;
  }
  const dupes = Object.values(textCounts).reduce((sum, c) => sum + Math.max(c - 1, 0), 0);
  if (submissions.length > 3 && dupes / submissions.length > 0.15) {
    warnings.push("Duplicate content detected: " + dupes + " duplicates (" + Math.round(dupes / submissions.length * 100) + "%). Possible coordinated campaign.");
  }

  // Temporal clustering (brigading)
  if (submissions.length >= 10) {
    const times = submissions.map(s => new Date(s.submitted_at).getTime()).sort((a, b) => a - b);
    const span = times[times.length - 1] - times[0];
    if (span === 0) {
      warnings.push("All submissions have identical timestamps. Possible data import artifact.");
    } else if (span > 0) {
      const windowSize = Math.max(Math.floor(submissions.length * 0.1), 1);
      for (let i = 0; i <= times.length - windowSize; i++) {
        const windowSpan = times[i + windowSize - 1] - times[i];
        if (windowSpan < span * 0.05 && windowSize > submissions.length * 0.5) {
          warnings.push("Temporal burst detected: large cluster of submissions in a very short window. Possible brigading.");
          break;
        }
      }
    }
  }

  // Single participant dominance
  const authorCounts = {};
  for (const s of submissions) {
    authorCounts[s.anonymous_id] = (authorCounts[s.anonymous_id] || 0) + 1;
  }
  const maxByOne = Math.max(...Object.values(authorCounts));
  if (submissions.length > 5 && maxByOne / submissions.length > 0.5) {
    warnings.push("One participant accounts for " + Math.round(maxByOne / submissions.length * 100) + "% of submissions. Limited diversity of voice.");
  }

  return warnings;
}

/* ---- Cluster labeling heuristic ---- */

function labelCluster(members) {
  // Use the dominant stance to name the cluster
  let supportCount = 0, opposeCount = 0, neutralCount = 0;
  for (const m of members) {
    if (m.scores.stance > 0.03) supportCount++;
    else if (m.scores.stance < -0.03) opposeCount++;
    else neutralCount++;
  }
  const total = members.length;
  if (supportCount > opposeCount && supportCount > neutralCount) {
    return "Supportive voices (" + Math.round(supportCount / total * 100) + "%)";
  }
  if (opposeCount > supportCount && opposeCount > neutralCount) {
    return "Critical voices (" + Math.round(opposeCount / total * 100) + "%)";
  }
  return "Nuanced / mixed (" + Math.round(neutralCount / total * 100) + "%)";
}

/* ---- Main analysis runner ---- */

function runAnalysis(topicId) {
  const el = document.getElementById("analysis-content");
  if (!topicId) {
    el.innerHTML = '<div class="analysis-empty">Select a topic to see collective intelligence analysis.</div>';
    return;
  }

  const allSubs = [...state.submissions.values()].filter(s => s.topic_id === topicId);
  if (!allSubs.length) {
    el.innerHTML = '<div class="analysis-empty">No submissions yet. Analysis begins automatically as opinions arrive.</div>';
    return;
  }

  const opinions = allSubs.filter(s => s.submission_type === "opinion" || s.submission_type === "idea");
  const votes = allSubs.filter(s => s.submission_type === "vote");
  const topic = state.topics.get(topicId);

  // Score all opinions
  const scored = opinions.map(s => ({
    ...s,
    scores: scoreSentiment(s.content),
  }));

  // Aggregate sentiment
  const aggStance = scored.length ? scored.reduce((sum, s) => sum + s.scores.stance, 0) / scored.length : 0;
  const aggUrgency = scored.length ? scored.reduce((sum, s) => sum + s.scores.urgency, 0) / scored.length : 0;
  const aggCertainty = scored.length ? scored.reduce((sum, s) => sum + s.scores.certainty, 0) / scored.length : 0;

  // Stance distribution
  let supportPct = 0, opposePct = 0, neutralPct = 0;
  if (scored.length) {
    const sup = scored.filter(s => s.scores.stance > 0.03).length;
    const opp = scored.filter(s => s.scores.stance < -0.03).length;
    const neu = scored.length - sup - opp;
    supportPct = Math.round(sup / scored.length * 100);
    opposePct = Math.round(opp / scored.length * 100);
    neutralPct = 100 - supportPct - opposePct;
  }

  // Cluster opinions
  let clusterHTML = "";
  if (scored.length >= 3) {
    const k = Math.min(Math.max(2, Math.floor(scored.length / 3)), 5);
    const vectors = scored.map(s => [s.scores.stance, s.scores.urgency, s.scores.certainty, s.scores.intensity]);
    const labels = kmeans(vectors, k);

    const clusters = {};
    for (let i = 0; i < scored.length; i++) {
      const cid = labels[i];
      if (!clusters[cid]) clusters[cid] = [];
      clusters[cid].push(scored[i]);
    }

    const clusterEntries = Object.entries(clusters).sort((a, b) => b[1].length - a[1].length);
    clusterHTML = clusterEntries.map(([cid, members]) => {
      const label = labelCluster(members);
      const rep = members.sort((a, b) => b.content.length - a.content.length)[0];
      const repText = rep.content.length > 150 ? rep.content.slice(0, 150) + "..." : rep.content;
      return '<div class="cluster-card">' +
        '<h4>' + esc(label) + '</h4>' +
        '<div class="cluster-size">' + members.length + ' of ' + scored.length + ' opinions</div>' +
        '<div class="cluster-rep">"' + esc(repText) + '"</div>' +
        '</div>';
    }).join("");
  } else if (scored.length > 0) {
    clusterHTML = '<div style="color:var(--text2); font-size:0.82rem;">Need at least 3 opinions for clustering. Currently: ' + scored.length + '.</div>';
  }

  // Vote tally
  let voteHTML = "";
  if (votes.length > 0 && topic && topic.vote_options && topic.vote_options.length) {
    const tally = {};
    for (const opt of topic.vote_options) tally[opt] = 0;
    for (const v of votes) {
      if (tally[v.content] !== undefined) tally[v.content]++;
      else tally[v.content] = (tally[v.content] || 0) + 1;
    }
    const maxVotes = Math.max(...Object.values(tally), 1);
    voteHTML = Object.entries(tally).map(([opt, count]) => {
      const pct = Math.round(count / votes.length * 100);
      return '<div class="bar-row">' +
        '<span class="bar-label">' + esc(opt) + '</span>' +
        '<span class="bar-track"><span class="bar-fill support" style="width:' + (count / maxVotes * 100) + '%"></span></span>' +
        '<span class="bar-value">' + count + ' (' + pct + '%)</span>' +
        '</div>';
    }).join("");
  }

  // Bias warnings
  const biasWarnings = detectBias(allSubs);
  const biasHTML = biasWarnings.map(w =>
    '<div class="bias-warning">' + esc(w) + '</div>'
  ).join("");

  // Build the full panel
  let html = '<div class="analysis-grid">';

  // Box 1: Stance distribution
  html += '<div class="analysis-box">';
  html += '<h3>Stance Distribution</h3>';
  html += '<div class="consensus-meter">';
  html += '<div class="seg" style="width:' + supportPct + '%; background:var(--green);"></div>';
  html += '<div class="seg" style="width:' + neutralPct + '%; background:var(--orange);"></div>';
  html += '<div class="seg" style="width:' + opposePct + '%; background:var(--red);"></div>';
  html += '</div>';
  html += '<div class="consensus-label"><span>Support ' + supportPct + '%</span><span>Mixed ' + neutralPct + '%</span><span>Oppose ' + opposePct + '%</span></div>';
  html += '<div style="font-size:0.8rem; color:var(--text2);">' + scored.length + ' opinions analyzed</div>';
  html += '</div>';

  // Box 2: Sentiment dimensions
  html += '<div class="analysis-box">';
  html += '<h3>Sentiment Dimensions</h3>';
  // Stance bar (centered around 0)
  const stancePct = Math.round((aggStance + 1) / 2 * 100);
  html += '<div class="bar-row"><span class="bar-label">Stance</span>';
  html += '<span class="bar-track"><span class="bar-fill ' + (aggStance >= 0 ? "support" : "oppose") + '" style="width:' + stancePct + '%"></span></span>';
  html += '<span class="bar-value">' + (aggStance >= 0 ? "+" : "") + aggStance.toFixed(2) + '</span></div>';
  // Urgency
  const urgPct = Math.round(aggUrgency * 100);
  html += '<div class="bar-row"><span class="bar-label">Urgency</span>';
  html += '<span class="bar-track"><span class="bar-fill urgency" style="width:' + urgPct + '%"></span></span>';
  html += '<span class="bar-value">' + urgPct + '%</span></div>';
  // Certainty
  const certPct = Math.round((aggCertainty + 1) / 2 * 100);
  html += '<div class="bar-row"><span class="bar-label">Certainty</span>';
  html += '<span class="bar-track"><span class="bar-fill certainty" style="width:' + certPct + '%"></span></span>';
  html += '<span class="bar-value">' + aggCertainty.toFixed(2) + '</span></div>';
  html += '</div>';

  html += '</div>'; // end analysis-grid

  // Vote results (if any)
  if (voteHTML) {
    html += '<div class="analysis-box" style="margin-bottom:1rem;">';
    html += '<h3>Vote Results (' + votes.length + ' votes)</h3>';
    html += voteHTML;
    html += '</div>';
  }

  // Opinion clusters
  if (clusterHTML) {
    html += '<div style="margin-bottom:1rem;">';
    html += '<h3 style="font-size:0.85rem; color:var(--text2); text-transform:uppercase; letter-spacing:0.04em; margin-bottom:0.6rem;">Opinion Clusters</h3>';
    html += clusterHTML;
    html += '</div>';
  }

  // Bias warnings
  if (biasHTML) {
    html += '<div style="margin-bottom:0.5rem;">';
    html += '<h3 style="font-size:0.85rem; color:var(--text2); text-transform:uppercase; letter-spacing:0.04em; margin-bottom:0.6rem;">Data Quality Alerts</h3>';
    html += biasHTML;
    html += '</div>';
  }

  // Methodology note
  html += '<div style="font-size:0.75rem; color:var(--text2); margin-top:0.75rem; padding-top:0.75rem; border-top:1px solid var(--border);">';
  html += 'Analysis runs locally in your browser using lexicon-based sentiment scoring and K-Means clustering on sentiment feature vectors. ';
  html += 'All peers compute the same results independently from the same replicated data. No external AI service is contacted.';
  html += '</div>';

  el.innerHTML = html;
}

/* ==================================================================
   BOOT — open IndexedDB, rehydrate state, then check for auto-join
   ================================================================== */

document.addEventListener("DOMContentLoaded", async () => {
  // 1. Open IndexedDB
  await store.open();
  if (store.db) {
    netLog("IndexedDB opened: " + DB_NAME, "ok");
  } else {
    netLog("IndexedDB unavailable — running in-memory only", "warn");
  }

  // 2. Rehydrate state from durable storage
  const loaded = await rehydrate();
  if (loaded > 0) {
    netLog("Rehydrated " + loaded + " entries from IndexedDB", "ok");
    refreshAll();
  }

  // 3. Update storage display
  await updateStorageStats();

  // 4. Auto-join the global mesh — no room codes, one network for all
  joinGlobalMesh();
});
</script>
</body>
</html>
